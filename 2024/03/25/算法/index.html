<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta name="description" content="个人笔记 &amp; 碎碎念" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>算法 |  岍翛</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-算法"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  算法
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/03/25/%E7%AE%97%E6%B3%95/" class="article-date">
  <time datetime="2024-03-25T06:36:47.000Z" itemprop="datePublished">2024-03-25</time>
</a>   
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">17k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">97 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> x = q[(l+r)/<span class="number">2</span>], i = l - <span class="number">1</span>, j = r + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; j)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">do</span> i++; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">		<span class="keyword">do</span> j--; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">		<span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">quick_sort</span>(q, l, j);</span><br><span class="line">	<span class="built_in">quick_sort</span>(q, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q[i]);</span><br><span class="line">	<span class="built_in">quick_sort</span>(q, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, q[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="！归并排序"><a href="#！归并排序" class="headerlink" title="！归并排序"></a>！归并排序</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 1e6 + 10;</span><br><span class="line">int q[N], temp[N];</span><br><span class="line">int n;</span><br><span class="line"></span><br><span class="line">void merge_sort(int q[], int l, int r)</span><br><span class="line">&#123;</span><br><span class="line">	if (l &gt;= r) return;</span><br><span class="line"></span><br><span class="line">	int mid = l + r &gt;&gt; 1;</span><br><span class="line">	merge_sort(q, l, mid), merge_sort(q, mid + 1, r);</span><br><span class="line">	int k = 0, i = l, j = mid + 1;</span><br><span class="line">	while (i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">		if (q[i] &lt;= q[j]) temp[k++] = q[i++];</span><br><span class="line">		else temp[k++] = q[j++];</span><br><span class="line">	while (i &lt;= mid) temp[k++] = q[i++];</span><br><span class="line">	while (j &lt;= r) temp[k++] = q[j++];</span><br><span class="line"></span><br><span class="line">	for (int i = l, j = 0; i &lt;= r; i++, j++) q[i] = temp[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">	for (int i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;q[i]);</span><br><span class="line"></span><br><span class="line">	merge_sort(q, 0, n-1);</span><br><span class="line"></span><br><span class="line">	for (int i = 0; i &lt; n; i++) printf(&quot;%d &quot;, q[i]);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="！二分"><a href="#！二分" class="headerlink" title="！二分"></a>！二分</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q[i]);</span><br><span class="line">	<span class="keyword">while</span> (m--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">		<span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (l &lt; r)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (q[mid] &gt;= x) r = mid;</span><br><span class="line">			<span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (q[l] != x) cout &lt;&lt; <span class="string">&quot;-1 -1&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; l &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">			l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">while</span> (l &lt; r)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span> (q[mid] &lt;= x) l = mid;</span><br><span class="line">				<span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			cout &lt;&lt; l &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>#include<iostream><br>#include<vector><br>using namespace std;</p>
<p>const int N &#x3D; 1e6 + 10;</p>
<p>vector<int> add(vector<int>&amp; A, vector<int>&amp; B)<br>{<br>    vector<int> C;</p>
<pre><code>int t = 0;
for (int i = 0; i &lt; A.size() || i &lt; B.size(); i++)
&#123;
    if (i &lt; A.size()) t += A[i];
    if (i &lt; B.size()) t += B[i];
    C.push_back(t % 10);
    t /= 10;
&#125;
if (t) C.push_back(t);
return C;
</code></pre>
<p>}</p>
<p>int main()<br>{<br>    string a, b;<br>    vector<int> A, B;</p>
<pre><code>cin &gt;&gt; a &gt;&gt; b;
for (int i = a.size() - 1; i &gt;= 0; i--) A.push_back(a[i] - &#39;0&#39;);
for (int i = b.size() - 1; i &gt;= 0; i--) B.push_back(b[i] - &#39;0&#39;);

auto C = add(A, B);
for (int i = C.size() - 1; i &gt;= 0; i--) printf(&quot;%d&quot;, C[i]);
printf(&quot;\n&quot;);
return 0;
</code></pre>
<p>}</p>
<h1 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>#include<iostream><br>#include<vector><br>using namespace std;</p>
<p>bool cmp(vector<int>&amp; A, vector<int>&amp; B)<br>{<br>    if (A.size() !&#x3D; B.size()) return A.size() &gt; B.size();<br>    for (int i &#x3D; A.size() - 1; i &gt;&#x3D; 0; i–)<br>        if (A[i] !&#x3D; B[i])<br>            return A[i] &gt; B[i];<br>    return true;<br>}</p>
<p>vector<int> sub(vector<int>&amp; A, vector<int>&amp; B)<br>{<br>    vector<int> C;</p>
<pre><code>for (int i = 0, t = 0; i &lt; A.size(); i++)
&#123;
    t = A[i] - t;
    if (i &lt; B.size()) t -= B[i];
    C.push_back((t + 10) % 10);
    if (t &lt; 0) t = 1;
    else t = 0;
&#125;
while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();

return C;
</code></pre>
<p>}</p>
<p>int main()<br>{<br>    string a, b;<br>    vector<int> A, B;</p>
<pre><code>cin &gt;&gt; a &gt;&gt; b;
for (int i = a.size() - 1; i &gt;= 0; i--) A.push_back(a[i] - &#39;0&#39;);
for (int i = b.size() - 1; i &gt;= 0; i--) B.push_back(b[i] - &#39;0&#39;);

if (cmp(A, B))
&#123;
    auto C = sub(A, B);
    for (int i = C.size() - 1; i &gt;= 0; i--) printf(&quot;%d&quot;, C[i]);
&#125;
else 
&#123;
    auto C = sub(B, A);
    printf(&quot;-&quot;);
    for (int i = C.size() - 1; i &gt;= 0; i--) printf(&quot;%d&quot;, C[i]);
&#125;
printf(&quot;\n&quot;);
return 0;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="高精度乘法"><a href="#高精度乘法" class="headerlink" title="高精度乘法"></a>高精度乘法</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>#include<iostream><br>#include<vector><br>using namespace std;</p>
<p>vector<int> mul(vector<int>&amp; A, int b)<br>{<br>    vector<int> C;</p>
<pre><code>for (int i = 0, t = 0; i &lt; A.size() || t; i++)
&#123;
    if (i &lt; A.size()) t += A[i] * b;
    C.push_back(t % 10);
    t /= 10;
&#125;
return C;
</code></pre>
<p>}<br>int main()<br>{<br>    string a;<br>    int b;</p>
<pre><code>cin &gt;&gt; a &gt;&gt; b;

vector&lt;int&gt;A;
for (int i = a.size() - 1; i &gt;= 0; i--) A.push_back(a[i] - &#39;0&#39;);

auto C = mul(A, b);

for (int i = C.size() - 1; i &gt;= 0; i--) printf(&quot;%d&quot;, C[i]);
printf(&quot;\n&quot;);
return 0;
</code></pre>
<p>}</p>
<h1 id="高精度除法"><a href="#高精度除法" class="headerlink" title="高精度除法"></a>高精度除法</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>#include &lt;bits&#x2F;stdc++.h&gt;<br>using namespace std;</p>
<p>vector<int> div(vector<int> &amp;A, int b, int &amp;r)<br>{<br>    vector<int>C;<br>    r &#x3D; 0;</p>
<pre><code>for(int i = A.size() - 1; i &gt;= 0; i--)
&#123;
    r = r * 10 + A[i];
    C.push_back(r/b);
    r %= b;
&#125;
reverse(C.begin(), C.end());
while(C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();
return C;
</code></pre>
<p>}<br>int main()<br>{<br>    string a;<br>    int b;<br>    cin &gt;&gt; a &gt;&gt; b;</p>
<pre><code>vector&lt;int&gt;A;
for(int i = a.size() - 1; i &gt;= 0; i--) A.push_back(a[i] - &#39;0&#39;);

int r;
auto C = div(A, b, r);

for(int i = C.size() - 1; i &gt;= 0; i--) printf(&quot;%d&quot;,C[i]);
cout &lt;&lt; endl &lt;&lt; r &lt;&lt; endl;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="！前缀和"><a href="#！前缀和" class="headerlink" title="！前缀和"></a>！前缀和</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N], s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n, m;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) s[i] = s[i - <span class="number">1</span>] + a[i];</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> l, r;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, s[r] - s[l - <span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="！二维前缀和-子矩阵的和"><a href="#！二维前缀和-子矩阵的和" class="headerlink" title="！二维前缀和 子矩阵的和"></a>！二维前缀和 子矩阵的和</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, q;</span><br><span class="line"><span class="type">int</span> a[N][N], s[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i] [j]);</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">			s[i][j] = s[i - <span class="number">1</span>][j] + s[i][j - <span class="number">1</span>] - s[i - <span class="number">1</span>][j - <span class="number">1</span>] + a[i][j]; <span class="comment">// 求前缀和</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (q--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x1, y1, x2, y2;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, s[x2][y2] - s[x1 - <span class="number">1</span>][y2] - s[x2][y1 - <span class="number">1</span>] + s[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>]); <span class="comment">// 算部分和	</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>#include<iostream><br>using namespace std;</p>
<p>const int N &#x3D; 100010;<br>int n, m;<br>int a[N], b[N];</p>
<p>void insert(int l, int r, int c)<br>{<br>    b[l] +&#x3D; c;<br>    b[r + 1] -&#x3D; c;<br>}<br>int main()<br>{<br>    scanf(“%d%d”, &amp;n, &amp;m);<br>    for (int i &#x3D; 1; i &lt;&#x3D; n; i++) scanf(“%d”, &amp;a[i]);</p>
<pre><code>for (int i = 1; i &lt;= n; i++) insert(i, i, a[i]); // b[i] = a[i] - a[i - 1];

while (m--)
&#123;
    int l, r, c;
    scanf(&quot;%d%d%d&quot;, &amp;l, &amp;r, &amp;c);
    insert(l, r, c);
&#125;
for (int i = 1; i &lt;= n; i++) b[i] += b[i - 1];

for (int i = 1; i &lt;= n; i++) printf(&quot;%d &quot;, b[i]);
return 0;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="二维差分-差分矩阵"><a href="#二维差分-差分矩阵" class="headerlink" title="二维差分  差分矩阵"></a>二维差分  差分矩阵</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>#include<iostream><br>using namespace std;</p>
<p>const int N &#x3D; 1010;</p>
<p>int n, m, q;<br>int a[N] [N], b[N] [N];</p>
<p>void insert(int x1, int y1, int x2, int y2, int c)<br>{<br>    b[x1] [y1] +&#x3D; c;<br>    b[x2 + 1] [y1] -&#x3D; c;<br>    b[x1] [y2 + 1] -&#x3D; c;<br>    b[x2 + 1] [y2 + 1] +&#x3D; c;<br>}</p>
<p>int main()<br>{<br>    scanf(“%d%d%d”, &amp;n, &amp;m, &amp;q);</p>
<pre><code>for (int i = 1; i &lt;= n; i++)
    for (int j = 1; j &lt;= m; j++)
        scanf(&quot;%d&quot;, &amp;a[i][j]);

for (int i = 1; i &lt;= n; i++)
    for (int j = 1; j &lt;= m; j++)
        insert(i, j, i, j, a[i][j]);

while (q--)
&#123;
    int x1, y1, x2, y2, c;
    cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; c;
    insert(x1, y1, x2, y2, c);
&#125;
for (int i = 1; i &lt;= n; i++)
    for (int j = 1; j &lt;= m; j++)
        b[i][j] += b[i - 1][j] + b[i][j - 1] - b[i - 1][j - 1];

for (int i = 1; i &lt;= n; i++)
&#123;
    for (int j = 1; j &lt;= m; j++) printf(&quot;%d &quot;, b[i][j]);
    puts(&quot;&quot;);
&#125;
return 0;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="双指针算法（板子）"><a href="#双指针算法（板子）" class="headerlink" title="双指针算法（板子）"></a>双指针算法（板子）</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>#include<iostream><br>using namespace std;<br>int main()<br>{<br>    for (int i &#x3D; 0, j &#x3D; 0; i &lt; n; i++)<br>        while (j &lt; i &amp;&amp; check(i, j)) j++;<br>    return 0;<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="双指针-最长连续不重复子序列"><a href="#双指针-最长连续不重复子序列" class="headerlink" title="双指针  最长连续不重复子序列"></a>双指针  最长连续不重复子序列</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>#include&lt;bits&#x2F;stdc++.h&gt;<br>using namespace std;</p>
<p>const int N &#x3D; 100010;</p>
<p>int n;<br>int a[N], s[N]; &#x2F;&#x2F; s[i]数组表示i数字在该区间所包围的个数</p>
<p>int main()<br>{<br>    cin &gt;&gt; n;<br>    for (int i &#x3D; 0; i &lt; n; i++) cin &gt;&gt; a[i];</p>
<pre><code>int res = 0;																				
//每次i移动，j指针只可能往右走
for (int i = 0, j = 0; i &lt; n; i++)
&#123;
    s[a[i]]++; // 每次i指针移动1个位置，将移动得到的数字在s数组中存储的个数加一
    while (s[a[i]] &gt; 1) //每次只移动一个位置，所以只会有a[i]个数增加
    &#123;
        //将a[j]右移
        s[a[j]]--;
        j++;
    &#125;
    res = max(res, i - j + 1);
&#125;
cout &lt;&lt; res &lt;&lt; endl;
return 0;
&#125;
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="离散化-–区间和"><a href="#离散化-–区间和" class="headerlink" title="离散化 –区间和"></a>离散化 –区间和</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F;n的二进制表示第k位是几<br>&#x2F;&#x2F;先把第k位移到最后一位，n&gt;&gt;k；再看个位是几，x&amp;1<br>&#x2F;&#x2F;n&gt;&gt;k&amp;1</p>
<p>&#x2F;&#x2F;lowbit(x)：返回x的最后一位1及其右边的所有数<br>&#x2F;&#x2F;x&amp;-x &#x3D; x&amp;(~x+1)</p>
<p>&#x2F;&#x2F;vector<int>alls  存储所有待离散化的值<br>&#x2F;&#x2F;去重<br>&#x2F;&#x2F; 先排序 sort(alls.begin(),alls.end())  alls.erase(unique(alls.begin(),alls.end()),all.end())<br>&#x2F;&#x2F; unique会将（）区间内不重复的数放在前面，并返回最后一个不重复的数的下一个位置<br>&#x2F;&#x2F;二分求出x对应的离散化的值<br>#include<iostream><br>#include<vector><br>#include<algorithm><br>using namespace std;<br>typedef pair&lt;int, int&gt; PII;<br>const int N &#x3D; 300010;<br>int n, m;<br>int a[N], s[N];<br>vector<int>alls; &#x2F;&#x2F; alls中存入需要离散化的数<br>vector<PII>add, query; &#x2F;&#x2F; add存入要插入位置的值，query是待求区间的左右范围<br>&#x2F;&#x2F;二分查找<br>int find(int x)<br>{<br>    int l &#x3D; 0, r &#x3D; alls.size() - 1;<br>    while (l &lt; r)<br>    {<br>        int mid &#x3D; l + r &gt;&gt; 1;<br>        if (alls[mid] &gt;&#x3D; x) r &#x3D; mid;<br>        else l &#x3D; mid + 1;<br>    }<br>    return r + 1;<br>}<br>int main()<br>{<br>    cin &gt;&gt; n &gt;&gt; m;<br>    for (int i &#x3D; 0; i &lt; n; i++)<br>    {<br>        int x, c;<br>        cin &gt;&gt; x &gt;&gt; c;<br>        add.push_back({ x,c });<br>        alls.push_back(x);<br>    }<br>    for (int i &#x3D; 0; i &lt; m; i++)<br>    {<br>        int l, r;<br>        cin &gt;&gt; l &gt;&gt; r;<br>        query.push_back({ l,r });<br>        alls.push_back(l);<br>        alls.push_back(r);<br>    }<br>    &#x2F;&#x2F;去重<br>    sort(alls.begin(), alls.end());<br>    alls.erase(unique(alls.begin(), alls.end()), alls.end());<br>    &#x2F;&#x2F;处理插入<br>    for (auto item : add)<br>    {<br>        int x &#x3D; find(item.first);<br>        a[x] +&#x3D; item.second;<br>    }<br>    &#x2F;&#x2F;预处理前缀和<br>    for (int i &#x3D; 1; i &lt;&#x3D; alls.size(); i++) s[i] &#x3D; s[i - 1] + a[i];<br>    &#x2F;&#x2F;处理询问<br>    for (auto item : query)<br>    {<br>        int l &#x3D; find(item.first), r &#x3D; find(item.second);<br>        cout &lt;&lt; s[r] - s[l - 1] &lt;&lt; endl;<br>    }<br>    return 0;<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>#include<iostream><br>#include<vector><br>#include<algorithm><br>using namespace std;<br>typedef pair&lt;int, int&gt; PII;<br>const int N &#x3D; 100010;<br>int n;<br>vector<PII> segs;<br>void merge(vector<PII>&amp; segs)<br>{<br>    vector<PII> res;<br>    sort(segs.begin(), segs.end());&#x2F;&#x2F; 元素为pair类型的vector容器sort按照first值大小排序<br>    int st &#x3D; -2e9, ed &#x3D; -2e9;<br>    &#x2F;&#x2F; 取左端点靠前的区间，其他区间与其有三种关系，包含，交集，空集<br>    &#x2F;&#x2F; 可以简化为两种情况 有无交集<br>    for (auto seg : segs)<br>        if (ed &lt; seg.first) &#x2F;&#x2F; 当两个区间没有交集的时候<br>        {<br>            if (st !&#x3D; -2e9) res.push_back({ st,ed });<br>            st &#x3D; seg.first, ed &#x3D; seg.second;<br>        }<br>        else ed &#x3D; max(ed, seg.second); &#x2F;&#x2F; 当两个区间有交集，合并时左端点一定是st，右端点为max(ed, seg.second)<br>    if (st !&#x3D; -2e9) res.push_back({ st,ed });&#x2F;&#x2F;for循环结束时最后一个区间还没插入<br>    segs &#x3D; res;<br>}<br>int main()<br>{<br>    cin &gt;&gt; n;<br>    for (int i &#x3D; 0; i &lt; n; i++)<br>    {<br>        int l, r;<br>        cin &gt;&gt; l &gt;&gt; r;<br>        segs.push_back({ l,r });<br>    }<br>    merge(segs);<br>    cout &lt;&lt; segs.size() &lt;&lt; endl;<br>    return 0;<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="！单调栈"><a href="#！单调栈" class="headerlink" title="！单调栈"></a>！单调栈</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>#include<iostream><br>using namespace std;</p>
<p>const int N &#x3D; 100010;</p>
<p>int n;<br>int stk[N], tt;</p>
<p>int main()<br>{<br>    cin.tie(0);<br>    ios::sync_with_stdio(false);<br>    cin &gt;&gt; n;<br>    for (int i &#x3D; 0; i &lt; n; i++)<br>    {<br>        int x;<br>        cin &gt;&gt; x;<br>        while (tt &amp;&amp; stk[tt] &gt;&#x3D; x) tt–; &#x2F;&#x2F;如果stk[tt]&gt;&#x3D;x，则在此之后stk[tt]不会再成为答案，则可将此值出栈<br>        if (tt) cout &lt;&lt; stk[tt] &lt;&lt; “ “ ;<br>        else cout &lt;&lt; -1 &lt;&lt; “ “;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">	stk[++tt] = x;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br></pre></td></tr></table></figure>

<p>}</p>
<h1 id="！滑动窗口"><a href="#！滑动窗口" class="headerlink" title="！滑动窗口"></a>！滑动窗口</h1><p>#include<iostream><br>using namespace std;</p>
<p>const int N &#x3D; 1000010;</p>
<p>int n, k;<br>int a[N], q[N];<br>int main()<br>{<br>    scanf(“%d%d”, &amp;n, &amp;k);<br>    for (int i &#x3D; 0; i &lt; n; i++) scanf(“%d”, &amp;a[i]);<br>    int hh &#x3D; 0, tt &#x3D; -1;<br>    for (int i &#x3D; 0; i &lt; n; i++)<br>    {<br>        if (hh &lt;&#x3D; tt &amp;&amp; i - k + 1 &gt; q[hh]) hh++;<br>        while (hh &lt;&#x3D; tt &amp;&amp; a[q[tt]] &gt;&#x3D; a[i]) tt–;<br>        q[++tt] &#x3D; i;<br>        if (i &gt;&#x3D; k - 1) printf(“%d “, a[q[hh]]);<br>    }<br>    puts(“”);<br>    hh &#x3D; 0, tt &#x3D; -1;<br>    for (int i &#x3D; 0; i &lt; n; i++)<br>    {<br>        if (hh &lt;&#x3D; tt &amp;&amp; i - k + 1 &gt; q[hh]) hh++;<br>        while (hh &lt;&#x3D; tt &amp;&amp; a[q[tt]] &lt;&#x3D; a[i]) tt–;<br>        q[++tt] &#x3D; i;<br>        if (i &gt;&#x3D; k - 1) printf(“%d “, a[q[hh]]);<br>    }<br>    puts(“”);<br>}</p>
<h1 id="KMP字符串"><a href="#KMP字符串" class="headerlink" title="KMP字符串"></a>KMP字符串</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>#include<iostream><br>using namespace std;</p>
<p>const int N &#x3D; 10010, M &#x3D; 100010;<br>int n, m;<br>char p[N], s[N];<br>int ne[N];</p>
<p>int main()<br>{<br>    cin &gt;&gt; n &gt;&gt; p + 1 &gt;&gt; m &gt;&gt; s + 1;</p>
<pre><code>//求next的过程
for (int i = 2, j = 0; i &lt;= n; i++)
&#123;
    while (j &amp;&amp; p[i] != p[j + 1]) j = ne[j]; // 也有kmp匹配的思想
    if (p[i] == p[j + 1]) j++;
    ne[i] = j;
&#125;

// kmp匹配过程
for (int i = 1, j = 0; i &lt;= m; i++)
&#123;
    while (j &amp;&amp; s[i] != p[j + 1]) j = ne[j];
    if (s[i] == p[j + 1]) j++;
    if (j == n)
    &#123;
        printf(&quot;%d &quot;, i - n);
        j = ne[j];
    &#125;
&#125;
return 0;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="trie字符串统计"><a href="#trie字符串统计" class="headerlink" title="trie字符串统计"></a>trie字符串统计</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>#include<iostream><br>using namespace std;</p>
<p>const int N &#x3D; 100010;</p>
<p>int son[N] [26], cnt[N], idx; &#x2F;&#x2F; 下标是0的点，既是根节点，又是空节点，son的值是该结点的特定值<br>char str[N];</p>
<p>void insert(char str[])<br>{<br>    int p &#x3D; 0;<br>    for (int i &#x3D; 0; str[i]; i++)<br>    {<br>        int u &#x3D; str[i] - ‘a’;<br>        if (!son[p] [u]) son[p] [u] &#x3D; ++idx; &#x2F;&#x2F; 每个结点都有特殊的idx标号<br>        p &#x3D; son[p] [u];<br>    }</p>
<pre><code>cnt[p]++; // 给最后一个结点做标记
</code></pre>
<p>}</p>
<p>int query(char str[])<br>{<br>    int p &#x3D; 0;<br>    for (int i &#x3D; 0; str[i]; i++)<br>    {<br>        int u &#x3D; str[i] - ‘a’;<br>        if (!son[p] [u]) return 0;<br>        p &#x3D; son[p] [u];<br>    }</p>
<pre><code>return cnt[p];
</code></pre>
<p>}</p>
<p>int main()<br>{<br>    int n;<br>    scanf(“%d”, &amp;n);<br>    while (n–)<br>    {<br>        char op[2];<br>        scanf(“%s%s”, op, str);<br>        if (op[0] &#x3D;&#x3D; ‘I’) insert(str);<br>        else printf(“%d\n”, query(str));<br>    }</p>
<pre><code>return 0;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="合并集合（并查集）"><a href="#合并集合（并查集）" class="headerlink" title="合并集合（并查集）"></a>合并集合（并查集）</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>#include<iostream><br>using namespace std;</p>
<p>const int N &#x3D; 100010;</p>
<p>int n, m;<br>int p[N]; &#x2F;&#x2F;存放结点的父节点，根节点p[x]&#x3D;x</p>
<p>int find(int x) &#x2F;&#x2F; 返回x的祖先结点+路径压缩<br>{<br>    if (p[x] !&#x3D; x) p[x] &#x3D; find(p[x]);<br>    return p[x];<br>}</p>
<p>int main()<br>{<br>    scanf(“%d%d”, &amp;n, &amp;m);</p>
<pre><code>for (int i = 1; i &lt;= n; i++) p[i] = i;

while (m--)
&#123;
    char op[2];
    int a, b;
    scanf(&quot;%s%d%d&quot;, op, &amp;a, &amp;b);

    if (op[0] == &#39;M&#39;) p[find(a)] = find(b);
    else
    &#123;
        if (find(a) == find(b)) puts(&quot;Yes&quot;);
        else puts(&quot;No&quot;);
    &#125;
&#125;
return 0;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="连通块中点的数量"><a href="#连通块中点的数量" class="headerlink" title="连通块中点的数量"></a>连通块中点的数量</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>#include<iostream><br>using namespace std;</p>
<p>const int N &#x3D; 100010;</p>
<p>int n, m;<br>int p[N], s[N]; &#x2F;&#x2F;存放结点的父节点，根节点p[x]&#x3D;x<br>                    &#x2F;&#x2F; s用来存放某个连通图的结点个数，只有根节点的s有意义<br>int find(int x) &#x2F;&#x2F; 返回x的祖先结点+路径压缩<br>{<br>    if (p[x] !&#x3D; x) p[x] &#x3D; find(p[x]);<br>    return p[x];<br>}</p>
<p>int main()<br>{<br>    scanf(“%d%d”, &amp;n, &amp;m);</p>
<pre><code>for (int i = 1; i &lt;= n; i++)
&#123;
    p[i] = i;
    s[i] = 1;
&#125;

while (m--)
&#123;
    char op[5];
    int a, b;
    scanf(&quot;%s&quot;, op);

    if (op[0] == &#39;C&#39;)
    &#123;
        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
        if (find(a) == find(b)) continue;
        s[find(b)] += s[find(a)];
        p[find(a)] = find(b);
    &#125;
    else if(op[1] == &#39;1&#39;)
    &#123;
        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
        if (find(a) == find(b)) puts(&quot;Yes&quot;);
        else puts(&quot;No&quot;);
    &#125;
    else
    &#123;
        scanf(&quot;%d&quot;, &amp;a);
        printf(&quot;%d\n&quot;, s[find(a)]);
    &#125;
&#125;
return 0;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>#include<iostream><br>#include<algorithm><br>using namespace std;</p>
<p>const int N &#x3D; 100010;</p>
<p>int n, m;<br>int h[N], S; </p>
<p>void down(int u)<br>{<br>    int t &#x3D; u;<br>    if (u * 2 &lt;&#x3D; S &amp;&amp; h[u * 2] &lt; h[t]) t &#x3D; u * 2; &#x2F;&#x2F; u<em>2是u的左节点<br>    if (u * 2 + 1 &lt;&#x3D; S &amp;&amp; h[u * 2 + 1] &lt; h[t]) t &#x3D; u * 2 + 1; &#x2F;&#x2F; u</em>2+1是u的右节点<br>    if (u !&#x3D; t)<br>    {<br>        swap(h[u], h[t]);<br>        down(t);<br>    }<br>}</p>
<p>void up(int u)<br>{<br>    while (u &#x2F; 2 &amp;&amp; h[u &#x2F; 2] &gt; h[u])<br>    {<br>        swap(h[u &#x2F; 2], h[u]);<br>        u &#x2F;&#x3D; 2;<br>    }<br>}</p>
<p>int main()<br>{<br>    scanf(“%d%d”, &amp;n, &amp;m);<br>    for (int i &#x3D; 1; i &lt;&#x3D; n; i++) scanf(“%d”, &amp;h[i]);<br>    S &#x3D; n;</p>
<pre><code>for (int i = n / 2; i; i--) down(i);

while (m--)
&#123;
    printf(&quot;%d &quot;, h[1]);
    h[1] = h[S];
    S--;
    down(1);
&#125;
return 0;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="模拟堆"><a href="#模拟堆" class="headerlink" title="模拟堆"></a>模拟堆</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>#include<iostream><br>using namespace std;</p>
<p>const int N &#x3D; 100010;</p>
<p>int h[N], ph[N], hp[N], S; &#x2F;&#x2F; ph[k]存第k个插入的点是那个点,hp[j]代表堆中第j个元素是第几次插入的</p>
<p>void heap_swap(int a, int b)<br>{<br>    swap(ph[hp[a]], ph[hp[b]]);<br>    swap(hp[a], hp[b]);<br>    swap(h[a], h[b]);<br>}</p>
<p>void down(int u)<br>{<br>    int t &#x3D; u;<br>    if (u * 2 &lt;&#x3D; S &amp;&amp; h[u * 2] &lt; h[t]) t &#x3D; u * 2;<br>    if (u * 2 + 1 &lt;&#x3D; S &amp;&amp; h[u * 2 + 1] &lt; h[t]) t &#x3D; u * 2 + 1;<br>    if (u !&#x3D; t)<br>    {<br>        heap_swap(u, t);<br>        down(t);<br>    }<br>}</p>
<p>void up(int u)<br>{<br>    while (u &#x2F; 2 &amp;&amp; h[u &#x2F; 2] &gt; h[u])<br>    {<br>        heap_swap(u &#x2F; 2, u);<br>        u &#x2F;&#x3D; 2;<br>    }<br>}</p>
<p>int main()<br>{<br>    int n, m &#x3D; 0; &#x2F;&#x2F; m代表是第几个插入的<br>    scanf(“%d”, &amp;n);<br>    while (n–)<br>    {<br>        char op[10];<br>        int k, x;</p>
<pre><code>    scanf(&quot;%s&quot;, op);
    if (!strcmp(op, &quot;I&quot;))
    &#123;
        scanf(&quot;%d&quot;, &amp;x);
        S++;
        m++;
        ph[m] = S, hp[S] = m;
        h[S] = x;
        up(S);
    &#125;
    else if (!strcmp(op, &quot;PM&quot;)) printf(&quot;%d\n&quot;, h[1]);
    else if (!strcmp(op, &quot;DM&quot;))
    &#123;
        heap_swap(1, S);
        S--;
        down(1);
    &#125;
    else if (!strcmp(op, &quot;D&quot;))
    &#123;
        scanf(&quot;%d&quot;, &amp;k);
        k = ph[k];
        heap_swap(k, S);
        S--;
        down(k), up(k);
    &#125;
    else
    &#123;
        scanf(&quot;%d%d&quot;, &amp;k, &amp;x);
        k = ph[k];
        h[k] = x;
        down(k), up(k);
    &#125;
&#125;
return 0;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="模拟散列表-拉链法"><a href="#模拟散列表-拉链法" class="headerlink" title="模拟散列表 拉链法"></a>模拟散列表 拉链法</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>#include<cstring><br>#include<iostream><br>using namespace std;</p>
<p>const int N &#x3D; 100003;</p>
<p>int h[N], e[N], ne[N], idx; &#x2F;&#x2F; h[i]中存放某个哈希值为i的下标，e[i]为第i个插入元素的值，ne[i]为第i个元素下个元素的值</p>
<p>void insert(int x)<br>{<br>    int k &#x3D; (x % N + N) % N;<br>    e[idx] &#x3D; x;<br>    ne[idx] &#x3D; h[k];<br>    h[k] &#x3D; idx++;<br>}</p>
<p>bool find(int x)<br>{<br>    int k &#x3D; (x % N + N) % N;<br>    for (int i &#x3D; h[k]; i !&#x3D; -1; i &#x3D; ne[i])<br>        if (e[i] &#x3D;&#x3D; x)<br>            return true;<br>    return false;<br>}	</p>
<p>int main()<br>{<br>    int n;<br>    scanf(“%d”, &amp;n);</p>
<pre><code>memset(h, -1, sizeof(h));

while (n--)
&#123;
    char op[2];

    int x;
    scanf(&quot;%s%d&quot;, op, &amp;x);

    if (*op == &#39;I&#39;) insert(x);
    else
    &#123;
        if (find(x)) puts(&quot;Yes&quot;);
        else puts(&quot;No&quot;);
    &#125;
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="模拟散列表-开放寻址法"><a href="#模拟散列表-开放寻址法" class="headerlink" title="模拟散列表 开放寻址法"></a>模拟散列表 开放寻址法</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>#include<cstring><br>#include<iostream><br>using namespace std;</p>
<p>const int N &#x3D; 200003, null &#x3D; 0x3f3f3f3f;<br>int h[N];</p>
<p>int find(int x)<br>{<br>    int k &#x3D; (x % N + N) % N;<br>    while (h[k] !&#x3D; null &amp;&amp; h[k] !&#x3D; x)<br>    {<br>        k++;<br>        if (k &#x3D;&#x3D; N) k &#x3D; 0;<br>    }<br>    return k;<br>}</p>
<p>int main()<br>{<br>    int n;<br>    scanf(“%d”, &amp;n);</p>
<pre><code>memset(h, 0x3f, sizeof(h));

while (n--)
&#123;
    char op[2];
    int x;
    scanf(&quot;%s%d&quot;, op, &amp;x);

    int k = find(x);
    if (*op == &#39;I&#39;) h[k] = x;
    else
    &#123;
        if (h[k] != null) puts(&quot;Yes&quot;);
        else puts(&quot;No&quot;);
    &#125;
&#125;
return 0;
</code></pre>
<p>}</p>
<h1 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>#include<iostream><br>using namespace std;</p>
<p>typedef unsigned long long ULL;<br>const int N &#x3D; 100010, P &#x3D; 131;</p>
<p>int n, m;<br>char str[N];<br>ULL h[N], p[N];</p>
<p>ULL get(int l, int r)<br>{<br>    return h[r] - h[l - 1] * p[r - l + 1];<br>}</p>
<p>int main()<br>{<br>    scanf(“%d%d%s”, &amp;n, &amp;m, str + 1);</p>
<pre><code>p[0] = 1;
for (int i = 1; i &lt;= n; i++)
&#123;
    p[i] = p[i - 1] * P;
    h[i] = h[i - 1] * P + str[i];
&#125;

while (m--)
&#123;
    int l1, r1, l2, r2;
    scanf(&quot;%d%d%d%d&quot;, &amp;l1, &amp;r1, &amp;l2, &amp;r2);
    if (get(l1, r1) == get(l2, r2)) puts(&quot;Yes&quot;);
    else puts(&quot;No&quot;);
&#125;
return 0;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="最大异或对–trie树"><a href="#最大异或对–trie树" class="headerlink" title="最大异或对–trie树"></a>最大异或对–trie树</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 100010, M = 31 * N;</span><br><span class="line"></span><br><span class="line">int n;</span><br><span class="line">int a[N];</span><br><span class="line">int son[M][2], idx; // son[p][u]的值存放的是下一结点所在的行</span><br><span class="line"></span><br><span class="line">void insert(int x)</span><br><span class="line">&#123;</span><br><span class="line">	int p = 0;</span><br><span class="line">	for (int i = 30; i &gt;= 0; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		int u = x &gt;&gt; i &amp; 1;</span><br><span class="line">		if (!son[p][u]) son[p][u] = ++idx;</span><br><span class="line">		p = son[p][u];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int query(int x)</span><br><span class="line">&#123;</span><br><span class="line">	int p = 0, res = 0;</span><br><span class="line">	for (int i = 30; i &gt;= 0; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		int u = x &gt;&gt; i &amp; 1;</span><br><span class="line">		if (son[p][!u])</span><br><span class="line">		&#123;</span><br><span class="line">			p = son[p][!u];</span><br><span class="line">			res = res * 2 + !u;</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			p = son[p][u];</span><br><span class="line">			res = res * 2 + u;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">	for (int i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">	int res = 0;</span><br><span class="line"></span><br><span class="line">	for (int i = 0; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		insert(a[i]);</span><br><span class="line">		int t = query(a[i]);</span><br><span class="line">		res = max(res, a[i] ^ t);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	printf(&quot;%d\n&quot;, res);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="！食物链-并查集"><a href="#！食物链-并查集" class="headerlink" title="！食物链-并查集"></a>！食物链-并查集</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 50010;</span><br><span class="line">int n, m;</span><br><span class="line">int p[N], d[N];</span><br><span class="line"></span><br><span class="line">int find(int x)</span><br><span class="line">&#123;</span><br><span class="line">	if (p[x] != x)</span><br><span class="line">	&#123;</span><br><span class="line">		int t = find(p[x]);</span><br><span class="line">		d[x] += d[p[x]];</span><br><span class="line">		p[x] = t;</span><br><span class="line">	&#125;</span><br><span class="line">	return p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><span class="line">	for (int i = 1; i &lt;= n; i++) p[i] = i;</span><br><span class="line"></span><br><span class="line">	int res = 0;</span><br><span class="line">	while (m--)</span><br><span class="line">	&#123;</span><br><span class="line">		int t, x, y;</span><br><span class="line">		scanf(&quot;%d%d%d&quot;, &amp;t, &amp;x, &amp;y);</span><br><span class="line"></span><br><span class="line">		if (x &gt; n || y &gt; n) res++;</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			int px = find(x), py = find(y);</span><br><span class="line">			if (t == 1)</span><br><span class="line">			&#123;</span><br><span class="line">				if (px == py &amp;&amp; (d[x] - d[y]) % 3) res++;</span><br><span class="line">				else if(px != py)</span><br><span class="line">				&#123;</span><br><span class="line">					p[px] = py;</span><br><span class="line">					d[px] = d[y] - d[x];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			else</span><br><span class="line">			&#123;</span><br><span class="line">				if (px == py &amp;&amp; (d[x] - d[y] - 1) % 3) res++;</span><br><span class="line">				else if (px != py)</span><br><span class="line">				&#123;</span><br><span class="line">					p[px] = py;</span><br><span class="line">					d[px] = d[y] + 1 - d[x];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;%d\n&quot;, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="分解质因数"><a href="#分解质因数" class="headerlink" title="分解质因数"></a>分解质因数</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void divide(int n)</span><br><span class="line">&#123;</span><br><span class="line">	for (int i = 2; i &lt;= n / i; i++)</span><br><span class="line">		if (n % i == 0)</span><br><span class="line">		&#123;</span><br><span class="line">			int s = 0;</span><br><span class="line">			while (n % i == 0)</span><br><span class="line">			&#123;</span><br><span class="line">				n /= i;</span><br><span class="line">				s++;</span><br><span class="line">			&#125;</span><br><span class="line">			printf(&quot;%d %d\n&quot;, i, s);</span><br><span class="line">		&#125;</span><br><span class="line">	if (n &gt; 1) printf(&quot;%d %d\n&quot;, n, 1);</span><br><span class="line">	puts(&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">	while (n--)</span><br><span class="line">	&#123;</span><br><span class="line">		int x;</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;x);</span><br><span class="line">		divide(x);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="筛质数"><a href="#筛质数" class="headerlink" title="筛质数"></a>筛质数</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 10000010;</span><br><span class="line"></span><br><span class="line">int primes[N], cnt;</span><br><span class="line">bool st[N];</span><br><span class="line"></span><br><span class="line">void get_primes(int n)</span><br><span class="line">&#123;</span><br><span class="line">	for (int i = 2; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if (!st[i]) primes[cnt++] = i;</span><br><span class="line">		for (int j = 0; primes[j] &lt;= n / i; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			st[primes[j] * i] = true;</span><br><span class="line">			if (i % primes[j] == 0) break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">	get_primes(n);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="试除法求约数"><a href="#试除法求约数" class="headerlink" title="试除法求约数"></a>试除法求约数</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; get_divisors(int n)</span><br><span class="line">&#123;</span><br><span class="line">	vector&lt;int&gt; res;</span><br><span class="line"></span><br><span class="line">	for (int i = 1; i &lt;= n / i; i++)</span><br><span class="line">		if (n % i == 0)</span><br><span class="line">		&#123;</span><br><span class="line">			res.push_back(i);</span><br><span class="line">			if (i != n / i) res.push_back(n / i);</span><br><span class="line">		&#125;</span><br><span class="line">	sort(res.begin(), res.end());</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">	while (n--)</span><br><span class="line">	&#123;</span><br><span class="line">		int x;</span><br><span class="line">		cin &gt;&gt; x;</span><br><span class="line">		auto res = get_divisors(x);</span><br><span class="line">		for (auto t : res) cout &lt;&lt; t &lt;&lt; &#x27; &#x27;;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="约数个数"><a href="#约数个数" class="headerlink" title="约数个数"></a>约数个数</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;unordered_map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef long long LL;</span><br><span class="line"></span><br><span class="line">const int mod = 1e9 + 7;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	unordered_map&lt;int, int&gt; primes;</span><br><span class="line">	while (n--)</span><br><span class="line">	&#123;</span><br><span class="line">		int x;</span><br><span class="line">		cin &gt;&gt; x;</span><br><span class="line">		for (int i = 2; i &lt;= x / i; i++)</span><br><span class="line">			while (x % i == 0)</span><br><span class="line">			&#123;</span><br><span class="line">				x /= i;</span><br><span class="line">				primes[i]++;</span><br><span class="line">			&#125;</span><br><span class="line">		if (x &gt; 1) primes[x]++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	LL res = 1;</span><br><span class="line">	for (auto prime : primes) res = res * (prime.second + 1) % mod;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int gcd(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">	return b ? gcd(b, a % b) : a;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">	while (n--)</span><br><span class="line">	&#123;</span><br><span class="line">		int a, b;</span><br><span class="line">		scanf(&quot;%d%d&quot;, &amp;a, &amp;b);</span><br><span class="line">		printf(&quot;%d\n&quot;, gcd(a, b));</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	while (n--)</span><br><span class="line">	&#123;</span><br><span class="line">		int a;</span><br><span class="line">		cin &gt;&gt; a;</span><br><span class="line"></span><br><span class="line">		int res = a;</span><br><span class="line">		for (int i = 2; i &lt;= a / i; i++)</span><br><span class="line">			if (a % i == 0)</span><br><span class="line">			&#123;</span><br><span class="line">				res = res / i * (i - 1);</span><br><span class="line">				while (a % i == 0) a /= i;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		if (a &gt; 1) res = res / a * (a - 1);</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="筛法求欧拉函数"><a href="#筛法求欧拉函数" class="headerlink" title="筛法求欧拉函数"></a>筛法求欧拉函数</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef long long LL;</span><br><span class="line">const int N = 1000010;</span><br><span class="line">int primes[N], cnt;</span><br><span class="line">int phi[N];</span><br><span class="line">bool st[N];</span><br><span class="line">LL get_euler(int n)</span><br><span class="line">&#123;</span><br><span class="line">	phi[1] = 1;</span><br><span class="line">	for (int i = 2; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if (!st[i])</span><br><span class="line">		&#123;</span><br><span class="line">			primes[cnt++] = i;</span><br><span class="line">			phi[i] = i - 1;</span><br><span class="line">		&#125;</span><br><span class="line">		for (int j = 0; primes[j] &lt;= n / i; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			st[primes[j] * i] = true;</span><br><span class="line">			if (i % primes[j] == 0)</span><br><span class="line">			&#123;</span><br><span class="line">				phi[primes[j] * i] = primes[j] * phi[i];</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			phi[primes[j] * i] = phi[i] * (primes[j] - 1);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	LL res = 0;</span><br><span class="line">	for (int i = 1; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		res += phi[i];</span><br><span class="line">	&#125;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	cout &lt;&lt; get_euler(n) &lt;&lt; endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef long long LL;</span><br><span class="line"></span><br><span class="line">int qmi(int a, int k, int p)</span><br><span class="line">&#123;</span><br><span class="line">	int res = 1;</span><br><span class="line">	while (k)</span><br><span class="line">	&#123;</span><br><span class="line">		if (k &amp; 1) res = (LL)res * a % p;</span><br><span class="line">		k &gt;&gt;= 1;</span><br><span class="line">		a = (LL)a * a % p;</span><br><span class="line">	&#125;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line"></span><br><span class="line">	int a, k, p;</span><br><span class="line">	while (n--)</span><br><span class="line">	&#123;</span><br><span class="line">		scanf(&quot;%d%d%d&quot;, &amp;a, &amp;k, &amp;p);</span><br><span class="line">		printf(&quot;%d\n&quot;, qmi(a, k, p));</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="高斯消元法"><a href="#高斯消元法" class="headerlink" title="高斯消元法"></a>高斯消元法</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 110;</span><br><span class="line">// C++浮点数存在误差，不能直接判断0，要判断是否小于一个很小的数，如果小于这个很小的数，就认为是0，如小于1e-6</span><br><span class="line">const double eps = 1e-6;</span><br><span class="line"></span><br><span class="line">int n;</span><br><span class="line">double a[N][N];</span><br><span class="line"></span><br><span class="line">int gauss()</span><br><span class="line">&#123;</span><br><span class="line">	int c, r; // c列，r行</span><br><span class="line">	for (c = 0, r = 0; c &lt; n; c++)</span><br><span class="line">	&#123;</span><br><span class="line">		int t = r;</span><br><span class="line">		// 1、找到当前这一列中绝对值最大的一行</span><br><span class="line">		for (int i = r; i &lt; n; i++)</span><br><span class="line">			if (fabs(a[i][c]) &gt; fabs(a[t][c]))</span><br><span class="line">				t = i;</span><br><span class="line">		// 如果这一列中最大值已经是0了，直接continue进入下一列</span><br><span class="line">		if (fabs(a[t][c]) &lt; eps) continue;</span><br><span class="line"></span><br><span class="line">		// 2、将这行换到最上面</span><br><span class="line">		for (int i = c; i &lt; n + 1; i++) swap(a[r][i], a[t][i]);</span><br><span class="line">		// 3、将该行第一个数变成1</span><br><span class="line">		for (int i = n; i &gt;= c; i--) a[r][i] /= a[r][c];</span><br><span class="line"></span><br><span class="line">		// 4、用这一行将下面每一行的该列清0</span><br><span class="line">		for (int i = r + 1; i &lt; n; i++)</span><br><span class="line">			if (fabs(a[r][c]) &gt; eps) // 要判断这个元素是否为0</span><br><span class="line">				for (int j = n; j &gt;= c; j--)</span><br><span class="line">					a[i][j] -= a[r][j] * a[i][c];</span><br><span class="line"></span><br><span class="line">		r++;// r表示消0后最后剩余的行数</span><br><span class="line">	&#125;</span><br><span class="line">	//在这之前已经消成了右上三角矩阵</span><br><span class="line">	if (r &lt; n)</span><br><span class="line">	&#123;</span><br><span class="line">		// 如果出现了等号左右一个为0一个非0，则说明无解</span><br><span class="line">		for (int i = r; i &lt; n; i++)</span><br><span class="line">			if (fabs(a[i][n]) &gt; eps)</span><br><span class="line">				return 2;</span><br><span class="line">		//否则无穷多解</span><br><span class="line">		return 1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//回溯计算每个值xi</span><br><span class="line">	for (int i = n - 1; i &gt;= 0; i--)</span><br><span class="line">		for (int j = i + 1; j &lt; n; j++)</span><br><span class="line">			a[i][n] -= a[j][n] * a[i][j];</span><br><span class="line">	//有唯一解</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	for (int i = 0; i &lt; n; i++)</span><br><span class="line">		for (int j = 0; j &lt; n + 1; j++)</span><br><span class="line">			cin &gt;&gt; a[i][j];</span><br><span class="line"></span><br><span class="line">	int t = gauss();</span><br><span class="line"></span><br><span class="line">	// 如果t==0 ，有唯一解</span><br><span class="line">	if (t == 0)</span><br><span class="line">	&#123;  // %。2lf 保留两位小数</span><br><span class="line">		for (int i = 0; i &lt; n; i++) printf(&quot;%.2lf\n&quot;, a[i][n]);</span><br><span class="line">	&#125;</span><br><span class="line">	//如果t==1 线性方程组存在无数解</span><br><span class="line">	else if (t == 1) puts(&quot;Infinite group solutins&quot;);</span><br><span class="line">	//否则无解</span><br><span class="line">	else puts(&quot;No solution&quot;);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="求组合数（1）"><a href="#求组合数（1）" class="headerlink" title="求组合数（1）"></a>求组合数（1）</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 2010, mod = 1e9 + 7;</span><br><span class="line">int c[N][N];</span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">	for (int i = 0; i &lt; N; i++)</span><br><span class="line">		for (int j = 0; j &lt;= i; j++)</span><br><span class="line">			if (!j) c[i][j] = 1;</span><br><span class="line">			else c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n;</span><br><span class="line">	init();</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	while (n--)</span><br><span class="line">	&#123;</span><br><span class="line">		int a, b;</span><br><span class="line">		cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">		cout &lt;&lt; c[a][b] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="求组合数（2）"><a href="#求组合数（2）" class="headerlink" title="求组合数（2）"></a>求组合数（2）</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef long long LL;</span><br><span class="line">const int N = 100010, mod = 1e9 + 7;</span><br><span class="line"></span><br><span class="line">int fact[N], infact[N];</span><br><span class="line"></span><br><span class="line">int qmi(int a, int k, int p) // 求某数的逆元</span><br><span class="line">&#123;</span><br><span class="line">	int res = 1;</span><br><span class="line">	while (k) // 将a的k次幂拆分成指数为2的多少次幂</span><br><span class="line">	&#123;</span><br><span class="line">		if (k &amp; 1) res = (LL)res * a % p;</span><br><span class="line">		a = (LL)a * a % p;</span><br><span class="line">		k &gt;&gt;= 1;</span><br><span class="line">	&#125;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	fact[0] = infact[0] = 1;</span><br><span class="line">	for (int i = 1; i &lt; N; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		fact[i] = (LL)fact[i - 1] * i % mod; // 阶乘</span><br><span class="line">		infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;// 阶乘的逆元</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	int n;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">	while (n--)</span><br><span class="line">	&#123;</span><br><span class="line">		int a, b;</span><br><span class="line">		scanf(&quot;%d%d&quot;, &amp;a, &amp;b);</span><br><span class="line">		cout &lt;&lt; (LL)fact[a] * infact[b] % mod * infact[a - b] % mod &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="求组合数（3）"><a href="#求组合数（3）" class="headerlink" title="求组合数（3）"></a>求组合数（3）</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef long long LL;</span><br><span class="line">int p;</span><br><span class="line"></span><br><span class="line">int qmi(int a, int k) // 求某数的逆元</span><br><span class="line">&#123;</span><br><span class="line">	int res = 1;</span><br><span class="line">	while (k)</span><br><span class="line">	&#123;</span><br><span class="line">		if (k &amp; 1) res = res * a % p;</span><br><span class="line">		a = (LL)a * a % p;</span><br><span class="line">		k &gt;&gt;= 1;</span><br><span class="line">	&#125;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int C(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">	int res = 1;</span><br><span class="line">	for (int i = 1, j = a; i &lt;= b; i++, j--)</span><br><span class="line">	&#123;</span><br><span class="line">		// 用分母分子项数相同的公式</span><br><span class="line">		res = (LL)res * j % p;</span><br><span class="line">		res = (LL)res * qmi(i, p - 2) % p;</span><br><span class="line">	&#125;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int locas(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">	if (a &lt; p &amp;&amp; b &lt; p) return C(a, b);</span><br><span class="line">	return (LL)C(a % p, b % p) * locas(a / p, b / p) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	while (n--)</span><br><span class="line">	&#123;</span><br><span class="line">		LL a, b;</span><br><span class="line">		cin &gt;&gt; a &gt;&gt; b &gt;&gt; p;</span><br><span class="line">		cout &lt;&lt; locas(a, b) &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="求组合数（4）"><a href="#求组合数（4）" class="headerlink" title="求组合数（4）"></a>求组合数（4）</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 5010;</span><br><span class="line"></span><br><span class="line">int primes[N], cnt;</span><br><span class="line">int sum[N];</span><br><span class="line">bool st[N];</span><br><span class="line"></span><br><span class="line">void get_primes(int n) // 求质数</span><br><span class="line">&#123;</span><br><span class="line">	for (int i = 2; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if (!st[i]) primes[cnt++] = i;</span><br><span class="line">		for (int j = 0; primes[j] &lt;= n / i; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			st[primes[j] * i] = true;</span><br><span class="line">			if (i % primes[j] == 0) break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int get(int n, int p) // n的阶乘里面p的个数</span><br><span class="line">&#123;</span><br><span class="line">	int res = 0;</span><br><span class="line">	while (n)</span><br><span class="line">	&#123;</span><br><span class="line">		res += n / p;</span><br><span class="line">		n /= p;</span><br><span class="line">	&#125;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; mul(vector&lt;int&gt; a, int b)</span><br><span class="line">&#123;</span><br><span class="line">	vector&lt;int&gt; c;</span><br><span class="line">	int t = 0;</span><br><span class="line">	for (int i = 0; i &lt; a.size(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		t += a[i] * b;</span><br><span class="line">		c.push_back(t % 10);</span><br><span class="line">		t /= 10;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	while (t)</span><br><span class="line">	&#123;</span><br><span class="line">		c.push_back(t % 10);</span><br><span class="line">		t /= 10;</span><br><span class="line">	&#125;</span><br><span class="line">	return c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int a, b;</span><br><span class="line">	cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line"></span><br><span class="line">	get_primes(a);</span><br><span class="line"></span><br><span class="line">	for (int i = 0; i &lt; cnt; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		int p = primes[i];</span><br><span class="line">		sum[i] = get(a, p) - get(b, p) - get(a - b, p);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vector&lt;int&gt; res;</span><br><span class="line">	res.push_back(1);</span><br><span class="line"></span><br><span class="line">	for (int i = 0; i &lt; cnt; i++)</span><br><span class="line">		for (int j = 0; j &lt; sum[i]; j++)</span><br><span class="line">			res = mul(res, primes[i]);</span><br><span class="line"></span><br><span class="line">	for (int i = res.size() - 1; i &gt;= 0; i--) printf(&quot;%d&quot;, res[i]);</span><br><span class="line">	puts(&quot;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="满足条件的01序列（组合数）"><a href="#满足条件的01序列（组合数）" class="headerlink" title="满足条件的01序列（组合数）"></a>满足条件的01序列（组合数）</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef long long LL;</span><br><span class="line">const int mod = 1e9 + 7;</span><br><span class="line"></span><br><span class="line">int qmi(int a, int k, int p) // 求逆元</span><br><span class="line">&#123;</span><br><span class="line">	int res = 1;</span><br><span class="line">	while (k)</span><br><span class="line">	&#123;</span><br><span class="line">		if (k &amp; 1) res = (LL)res * a % p;</span><br><span class="line">		a = (LL)a * a % p;</span><br><span class="line">		k &gt;&gt;= 1;</span><br><span class="line">	&#125;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	int a = 2 * n, b = n;</span><br><span class="line">	int res = 1;</span><br><span class="line">	</span><br><span class="line">	for (int i = a; i &gt; a - b; i--) res = (LL)res * i % mod;</span><br><span class="line">	for (int i = 1; i &lt;= b; i++) res = (LL)res * qmi(i, mod - 2, mod) % mod;</span><br><span class="line"></span><br><span class="line">	res = (LL)res * qmi(n + 1, mod - 2, mod) % mod;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="能被整除的数（容斥原理）"><a href="#能被整除的数（容斥原理）" class="headerlink" title="能被整除的数（容斥原理）"></a>能被整除的数（容斥原理）</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef long long LL;</span><br><span class="line">const int N = 20;</span><br><span class="line"></span><br><span class="line">int p[N];</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n, m;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">	// 用数组p存储m个质数</span><br><span class="line">	for (int i = 0; i &lt; m; i++) cin &gt;&gt; p[i];</span><br><span class="line"></span><br><span class="line">	int res = 0;</span><br><span class="line">	// 每个i代表1中可能的取法，最外层的循环遍历2的m次方后，可以取完所有的取法</span><br><span class="line">	// 从1开始枚举，枚举到1 &lt;&lt; m (左移m位，左移一位相当于*2)，总共有2^n-1种</span><br><span class="line">	for (int i = 1; i &lt; 1 &lt;&lt; m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		//t 代表当前所有质数的乘积，s代表什么当前选法包含几个集合</span><br><span class="line">		int t = 1, s = 0;</span><br><span class="line">		// 此循环就是提取出这个i值对应的取法</span><br><span class="line">		// 枚举m个质数，依次计算容斥原理的公式</span><br><span class="line">		for (int j = 0; j &lt; m; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			// 判断第j位是0还是1</span><br><span class="line">			if (i &gt;&gt; j &amp; 1)</span><br><span class="line">			&#123;</span><br><span class="line">				// 如果t（已有的质数选法）乘上这个质数大于给定的数n，说明1到n中的数不能被p整除</span><br><span class="line">				// 此时break，跳过这个质数</span><br><span class="line">				if ((LL)t * p[j] &gt; n)</span><br><span class="line">				&#123;</span><br><span class="line">					t = -1;</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">				t *= p[j]; // 将该质数乘到t中</span><br><span class="line">				s++; // 表示当前选法的集合个数（即t是多少个质数乘积）</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (t != -1) // 此时是符合要求的</span><br><span class="line">		&#123;</span><br><span class="line">			// 容斥原理前面的符号</span><br><span class="line">			if (s % 2) res += n / t; // n/t是向下取整</span><br><span class="line">			else res -= n / t;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Nim游戏（博弈论）"><a href="#Nim游戏（博弈论）" class="headerlink" title="Nim游戏（博弈论）"></a>Nim游戏（博弈论）</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n;</span><br><span class="line">	int res = 0;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">	// a1^a2^a3^……^an = 0 则先手必败</span><br><span class="line">	// a1^a2^a3^……^an != 0 则先手必胜</span><br><span class="line">	while (n--)</span><br><span class="line">	&#123;</span><br><span class="line">		int x;</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;x);</span><br><span class="line">		res ^= x;</span><br><span class="line">	&#125;</span><br><span class="line">	if (res) puts(&quot;Yes&quot;);</span><br><span class="line">	else puts(&quot;No&quot;);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="集合-Nim游戏"><a href="#集合-Nim游戏" class="headerlink" title="集合 Nim游戏"></a>集合 Nim游戏</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;unordered_set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 110, M = 10010;</span><br><span class="line">int n, m;</span><br><span class="line">int s[N], f[M];</span><br><span class="line"></span><br><span class="line">int sg(int x)</span><br><span class="line">&#123;</span><br><span class="line">	if (f[x] != -1) return f[x]; // 在后面返回时给f[x]赋值，减少递归</span><br><span class="line">	unordered_set&lt;int&gt; S; // 局部变量，故添加的只是该结点为弧尾所指向的弧头结点的序号</span><br><span class="line">	for (int i = 0; i &lt; m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		int sum = s[i];</span><br><span class="line">		if (x &gt;= sum) S.insert(sg(x - sum));</span><br><span class="line">	&#125;</span><br><span class="line">	for (int i = 0;; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if (!S.count(i)) return f[x] = i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	cin &gt;&gt; m;</span><br><span class="line">	for (int i = 0; i &lt; m; i++) cin &gt;&gt; s[i];</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	memset(f, -1, sizeof(f));</span><br><span class="line">	int res = 0;</span><br><span class="line">	for (int i = 0; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		int x;</span><br><span class="line">		cin &gt;&gt; x;</span><br><span class="line">		res ^= sg(x);</span><br><span class="line">	&#125;</span><br><span class="line">	if (res) puts(&quot;Yes&quot;);</span><br><span class="line">	else puts(&quot;No&quot;);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="表达整数的奇怪方式"><a href="#表达整数的奇怪方式" class="headerlink" title="表达整数的奇怪方式"></a>表达整数的奇怪方式</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef long long LL;</span><br><span class="line"></span><br><span class="line">LL exgcd(LL a, LL b, LL&amp; x, LL&amp; y)</span><br><span class="line">&#123;</span><br><span class="line">	if (!b)</span><br><span class="line">	&#123;</span><br><span class="line">		x = 1, y = 0;</span><br><span class="line">		return a;</span><br><span class="line">	&#125;</span><br><span class="line">	LL d = exgcd(b, a % b, y, x);</span><br><span class="line">	y -= a / b * x;</span><br><span class="line">	return d;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">	bool has_answer = true;</span><br><span class="line"></span><br><span class="line">	LL a1, m1;</span><br><span class="line">	cin &gt;&gt; a1 &gt;&gt; m1;</span><br><span class="line">	while (--n)</span><br><span class="line">	&#123;</span><br><span class="line">		LL a2, m2;</span><br><span class="line">		cin &gt;&gt; a2 &gt;&gt; m2;</span><br><span class="line"></span><br><span class="line">		LL k1, k2;</span><br><span class="line">		LL d = exgcd(a1, a2, k1, k2);</span><br><span class="line">		if ((m2 - m1) % d)</span><br><span class="line">		&#123;</span><br><span class="line">			has_answer = false;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		k1 *= (m2 - m1) / d;</span><br><span class="line">		LL t = a2 / d;</span><br><span class="line">		k1 = (k1 % t + t) % t;</span><br><span class="line">		m1 = a1 * k1 + m1;</span><br><span class="line">		a1 = abs(a1 / d * a2);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	if (has_answer)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; (m1 % a1 + a1) % a1 &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	else puts(&quot;-1&quot;);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="高斯消元解异或线性方程组"><a href="#高斯消元解异或线性方程组" class="headerlink" title="高斯消元解异或线性方程组"></a>高斯消元解异或线性方程组</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxn = 105;</span><br><span class="line"></span><br><span class="line">int n, a[maxn][maxn];</span><br><span class="line">int gauss()</span><br><span class="line">&#123;</span><br><span class="line">	int r, c;</span><br><span class="line">	for (r = c = 0; c &lt; n; c++)</span><br><span class="line">	&#123;</span><br><span class="line">		int t = r;</span><br><span class="line">		for (int i = r; i &lt; n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			if (a[i][c]) // 找出第c列中不为0的那一行</span><br><span class="line">			&#123;</span><br><span class="line">				t = i;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (!a[t][c]) continue; // 说明全为0</span><br><span class="line"></span><br><span class="line">		for (int i = c; i &lt;= n; i++) swap(a[t][i], a[r][i]); //将这行与第r行交换</span><br><span class="line">		// 消成上三角矩阵</span><br><span class="line">		for (int i = r + 1; i &lt; n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			if (a[i][c])</span><br><span class="line">				for (int j = c; j &lt;= n; j++) a[i][j] ^= a[r][j];</span><br><span class="line">		&#125;</span><br><span class="line">		r++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (r &lt; n)</span><br><span class="line">	&#123;</span><br><span class="line">		for (int i = r; i &lt; n; i++)</span><br><span class="line">			if (a[i][n])</span><br><span class="line">				return 2;</span><br><span class="line">		return 1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for (int i = n - 1; i &gt;= 0; i--)</span><br><span class="line">		for (int j = i + 1; j &lt; n; j++)</span><br><span class="line">			a[i][n] ^= a[i][j] &amp; a[j][n];</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	for (int i = 0; i &lt; n; i++)</span><br><span class="line">		for (int j = 0; j &lt;= n; j++) cin &gt;&gt; a[i][j];</span><br><span class="line">	int res = gauss();</span><br><span class="line">	if (res == 0)</span><br><span class="line">	&#123;</span><br><span class="line">		for (int i = 0; i &lt; n; i++) cout &lt;&lt; a[i][n] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	else if (res == 1) puts(&quot;Multiple sets of solutions&quot;);</span><br><span class="line">	else puts(&quot;No solution&quot;);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="台阶-Nim游戏"><a href="#台阶-Nim游戏" class="headerlink" title="台阶 Nim游戏"></a>台阶 Nim游戏</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">	int res = 0;</span><br><span class="line">	for (int i = 1; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		int x;</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;x);</span><br><span class="line"></span><br><span class="line">		if (i % 2)</span><br><span class="line">			res ^= x;</span><br><span class="line">	&#125;</span><br><span class="line">	if (res) puts(&quot;Yes&quot;);</span><br><span class="line">	else puts(&quot;No&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="！01背包问题"><a href="#！01背包问题" class="headerlink" title="！01背包问题"></a>！01背包问题</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1010;</span><br><span class="line"></span><br><span class="line">int n, m;</span><br><span class="line">int f[N]; // 体积为i的最大价值</span><br><span class="line">int v[N], w[N];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	for (int i = 1; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line">	// 将其想成二维数组，每次j从右往左求（为了使f[j]仍然保持为上一行的值）</span><br><span class="line">	// i=1开始表明从上往下求，每次更新有j容量背包的最大值</span><br><span class="line">	for (int i = 1; i &lt;= n; i++)</span><br><span class="line">		for (int j = m; j &gt;= v[i]; j--) // 从m开始是为了每次求的时候f[j-v[i]]仍然为上一行的值</span><br><span class="line">		&#123;</span><br><span class="line">			f[j] = max(f[j], f[j - v[i]] + w[i]); // 每次等号右边的f[j]为上一行的</span><br><span class="line">		&#125;</span><br><span class="line">	cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="！完全背包问题"><a href="#！完全背包问题" class="headerlink" title="！完全背包问题"></a>！完全背包问题</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1010;</span><br><span class="line">int f[N][N];</span><br><span class="line">int n, m;</span><br><span class="line">int v[N], w[N];</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int k;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	for (int i = 1; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">	for(int i = 1; i &lt;= n; i++)</span><br><span class="line">		for (int j = 1; j &lt;= m; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			f[i][j] = f[i - 1][j];</span><br><span class="line">			if (j &gt;= v[i]) f[i][j] = max(f[i - 1][j], f[i][j - v[i]] + w[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="！多重背包问题"><a href="#！多重背包问题" class="headerlink" title="！多重背包问题"></a>！多重背包问题</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> v[N], w[N], s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> k;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; s[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= s[i] &amp;&amp; k * v[i] &lt;= j; k++)</span><br><span class="line">			&#123;</span><br><span class="line">				f[i][j] = <span class="built_in">max</span>(f[i][j], f[i - <span class="number">1</span>][j - k * v[i]] + k * w[i]);</span><br><span class="line">			&#125;</span><br><span class="line">	cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="！多重背包问题2"><a href="#！多重背包问题2" class="headerlink" title="！多重背包问题2"></a>！多重背包问题2</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 25000, M = 2010;</span><br><span class="line">int f[N];</span><br><span class="line">int n, m;</span><br><span class="line">int v[N], w[N];</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	int cnt = 0;</span><br><span class="line">	for (int i = 1; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		int a, b, s;</span><br><span class="line">		cin &gt;&gt; a &gt;&gt; b &gt;&gt; s;</span><br><span class="line">		int k = 1;</span><br><span class="line">		while (k &lt;= s)</span><br><span class="line">		&#123;</span><br><span class="line">			cnt++;</span><br><span class="line">			v[cnt] = a * k;</span><br><span class="line">			w[cnt] = b * k;</span><br><span class="line">			s -= k;</span><br><span class="line">			k *= 2;</span><br><span class="line">		&#125;</span><br><span class="line">		if (s &gt; 0)</span><br><span class="line">		&#123;</span><br><span class="line">			cnt++;</span><br><span class="line">			v[cnt] = a * s;</span><br><span class="line">			w[cnt] = b * s;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 1，2，4，8，...这样的分发在这些数字之前任意组合可以组合成0-n之前的任何数</span><br><span class="line">	n = cnt;</span><br><span class="line">	for (int i = 1; i &lt;= n; i++) // n=cnt表示将之前的一种商品打包分为多种放在每一行</span><br><span class="line">		for (int j = m; j &gt;= v[i]; j--)</span><br><span class="line">			f[j] = max(f[j], f[j - v[i]] + w[i]); // 采用01背包的优化方式，每件物品只能取一次</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="分组背包问题"><a href="#分组背包问题" class="headerlink" title="分组背包问题"></a>分组背包问题</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> v[N][N], w[N][N], s[N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; s[i];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; s[i]; j++)</span><br><span class="line">			cin &gt;&gt; v[i][j] &gt;&gt; w[i][j];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt; <span class="number">0</span>; j--)</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; s[i]; k++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (v[i][k] &lt;= j)</span><br><span class="line">					f[j] = <span class="built_in">max</span>(f[j], f[j - v[i][k]] + w[i][k]);</span><br><span class="line">			&#125;</span><br><span class="line">	cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="！数字三角形"><a href="#！数字三角形" class="headerlink" title="！数字三角形"></a>！数字三角形</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1010, INF = 1e9;</span><br><span class="line">int n;</span><br><span class="line">int a[N][N];</span><br><span class="line">int f[N][N];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">	for (int i = 1; i &lt;= n; i++)</span><br><span class="line">		for (int j = 1; j &lt;= i; j++)</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;a[i][j]);</span><br><span class="line"></span><br><span class="line">	for (int i = 0; i &lt;= n; i++)</span><br><span class="line">		for (int j = 0; j &lt;= i + 1; j++)</span><br><span class="line">			f[i][j] = -INF;</span><br><span class="line"></span><br><span class="line">	f[1][1] = a[1][1];</span><br><span class="line">	for (int i = 2; i &lt;= n; i++)</span><br><span class="line">		for (int j = 1; j &lt;= i; j++)</span><br><span class="line">			f[i][j] = max(f[i - 1][j - 1] + a[i][j], f[i - 1][j] + a[i][j]);</span><br><span class="line">	int res = -INF;</span><br><span class="line">	for (int i = 1; i &lt;= n; i++) res = max(res, f[n][i]);</span><br><span class="line">	cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="！最长上升子序列"><a href="#！最长上升子序列" class="headerlink" title="！最长上升子序列"></a>！最长上升子序列</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> f[N], a[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		f[i] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">			<span class="keyword">if</span> (a[i] &gt; a[j])</span><br><span class="line">			&#123;</span><br><span class="line">				f[i] = <span class="built_in">max</span>(f[i], f[j] + <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) res = <span class="built_in">max</span>(res, f[i]);</span><br><span class="line">	cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="！最长公共子序列"><a href="#！最长公共子序列" class="headerlink" title="！最长公共子序列"></a>！最长公共子序列</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int n, m;</span><br><span class="line">const int N = 1010;</span><br><span class="line">char a[N], b[N];</span><br><span class="line">int f[N][N];</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><span class="line">	scanf(&quot;%s%s&quot;, a + 1, b + 1);</span><br><span class="line">	for (int i = 1; i &lt;= n; i++ )</span><br><span class="line">		for (int j = 1; j &lt;= m; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			f[i][j] = max(f[i - 1][j], f[i][j - 1]);</span><br><span class="line">			if (a[i] == b[j]) f[i][j] = max(f[i][j], f[i - 1][j - 1] + 1);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="石子合并"><a href="#石子合并" class="headerlink" title="石子合并"></a>石子合并</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 310;</span><br><span class="line"></span><br><span class="line">int n;</span><br><span class="line">int s[N];</span><br><span class="line">int f[N][N];</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">	for (int i = 1; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;s[i]);</span><br><span class="line">		s[i] += s[i - 1];</span><br><span class="line">	&#125;</span><br><span class="line">	// 计算将l到r区间的沙子合并所需的最小代价</span><br><span class="line">	// len = 1时代价为0</span><br><span class="line">	for(int len = 2; len &lt;= n; len++)</span><br><span class="line">		for (int i = 1; i + len - 1 &lt;= n; i++) // i + len - 1为r的位置</span><br><span class="line">		&#123;</span><br><span class="line">			int l = i, r = i + len - 1;</span><br><span class="line">			// 因为是取最小值，所以要将f[l][r]置于无穷大，否则答案为0</span><br><span class="line">			f[l][r] = 1e9;</span><br><span class="line">			// 两堆沙子合并的方式记作左边的沙子位置</span><br><span class="line">			for (int k = l; k &lt; r; k++) // 将l到r区间的沙子合并，有l,l+1,l+2,...,r-1种</span><br><span class="line">				f[l][r] = min(f[l][r], f[l][k] + f[k + 1][r] + s[r] - s[l - 1]);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	printf(&quot;%d\n&quot;, f[1][n]);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="蒙德里安的梦想"><a href="#蒙德里安的梦想" class="headerlink" title="蒙德里安的梦想"></a>蒙德里安的梦想</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 12, M = 1 &lt;&lt; N;</span><br><span class="line"></span><br><span class="line">long long f[N][M]; // 第一维表示列，第二维表示从前一列插过来的所有可能的状态用十进制表示</span><br><span class="line">bool st[M]; // 存储每种状态是否有奇数个连续的0，奇数个0是无效状态</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; state(M);</span><br><span class="line"></span><br><span class="line">int m, n;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	while (cin &gt;&gt; n &gt;&gt; m, n || m) // 读入n和m，并且不是两个0就继续读入</span><br><span class="line">	&#123;</span><br><span class="line">		// 预处理，对于每种状态，每列不能有奇数个0</span><br><span class="line">		// 1 &lt;&lt; n 相当于2的n次方，每行的每一个位置有0和1两种状态，故为2的n次方</span><br><span class="line">		for (int i = 0; i &lt; (1 &lt;&lt; n); i++)</span><br><span class="line">		&#123;</span><br><span class="line">			int cnt = 0; // 记录连续的0的个数</span><br><span class="line"></span><br><span class="line">			bool isVaild = true; // 某种状态没有奇数个连续的0则标记为true</span><br><span class="line"></span><br><span class="line">			for (int j = 0; j &lt; n; j++) // 遍历这一列，从上到下</span><br><span class="line">			&#123;</span><br><span class="line">				// i&gt;&gt;j 位运算，表示i（i在此处是一种状态）的二进制数的第j位</span><br><span class="line">				if ((i &gt;&gt; j) &amp; 1)</span><br><span class="line">				&#123;</span><br><span class="line">					if (cnt &amp; 1)</span><br><span class="line">					&#123;</span><br><span class="line">						// 这一位为1，看前面连续0的个数，如果为奇数则不合法</span><br><span class="line">						isVaild = false;</span><br><span class="line">						break;</span><br><span class="line">					&#125;</span><br><span class="line">					cnt = 0;</span><br><span class="line">				&#125;</span><br><span class="line">				else cnt++; // 该位仍为0，则统计0的计数器++</span><br><span class="line">			&#125;</span><br><span class="line">			if (cnt &amp; 1) isVaild = false; // 最下面的那一段判断一下连续0的个数</span><br><span class="line"></span><br><span class="line">			st[i] = isVaild; // 状态i是否有奇数个连续0的情况，输入到数组st中</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// 预处理，看i-2和i-1列伸出来的是否冲突</span><br><span class="line">		for (int j = 0; j &lt; (1 &lt;&lt; n); j++) // 对于第i列的所有状态</span><br><span class="line">		&#123;</span><br><span class="line">			state[j].clear(); // 多组输入，故清零</span><br><span class="line"></span><br><span class="line">			for (int k = 0; k &lt; (1 &lt;&lt; n); k++) // 对于第i-1列的所有状态</span><br><span class="line">			&#123;</span><br><span class="line">				if ((j &amp; k) == 0 &amp;&amp; st[j | k]) // j|k求的是在第i-1列横插的状态表示</span><br><span class="line">					state[j].push_back(k);</span><br><span class="line">				// state[j][k]表示第i列的状态j遇上第i-1列的状态k可行</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		memset(f, 0, sizeof(f));</span><br><span class="line"></span><br><span class="line">		f[0][0] = 1;// 表示第0列中从-1列横插过来的，因此第二维只能为0</span><br><span class="line">		for (int i = 1; i &lt;= m; i++) // i代表列</span><br><span class="line">		&#123;</span><br><span class="line">			for (int j = 0; j &lt; (1 &lt;&lt; n); j++) // j代表第i列的所有状态</span><br><span class="line">			&#123;</span><br><span class="line">				for (auto k : state[j]) // state[j]是vector容器，k则是遍历这个容器</span><br><span class="line">					f[i][j] += f[i - 1][k];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; f[m][0] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="最短hamilton路径"><a href="#最短hamilton路径" class="headerlink" title="最短hamilton路径"></a>最短hamilton路径</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 20, M = 1 &lt;&lt; N;</span><br><span class="line"></span><br><span class="line">int n;</span><br><span class="line">int w[N][N];</span><br><span class="line">int f[M][N]; // 从0走到j，i表示走过的路径</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	for (int i = 0; i &lt; n; i++)</span><br><span class="line">		for (int j = 0; j &lt; n; j++)</span><br><span class="line">			cin &gt;&gt; w[i][j];</span><br><span class="line"></span><br><span class="line">	memset(f, 0x3f, sizeof(f));</span><br><span class="line">	f[1][0] = 0;</span><br><span class="line">	for (int i = 0; i &lt; 1 &lt;&lt; n; i++) // 1 &lt;&lt; n 表示2的n次方，逐步更新到第0点到n-1点</span><br><span class="line">		for (int j = 0; j &lt; n; j++)</span><br><span class="line">			if (i &gt;&gt; j &amp; 1) // i &gt;&gt; j &amp; 1判断i的第j位是否为1</span><br><span class="line">				for (int k = 0; k &lt; n; k++)</span><br><span class="line">					if ((i - (1 &lt;&lt; j)) &gt;&gt; k &amp; 1) // 求j点的前一个点state_k = i-(1 &lt;&lt; j)</span><br><span class="line">						f[i][j] = min(f[i][j], f[i - (1 &lt;&lt; j)][k] + w[k][j]);</span><br><span class="line">	cout &lt;&lt; f[(1 &lt;&lt; n) - 1][n - 1] &lt;&lt; endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="没有上司的舞会"><a href="#没有上司的舞会" class="headerlink" title="没有上司的舞会"></a>没有上司的舞会</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">6010</span>;</span><br><span class="line"><span class="type">int</span> h[N], ne[N], e[N], idx;</span><br><span class="line"><span class="type">int</span> happy[N]; </span><br><span class="line"><span class="type">bool</span> has_father[N]; <span class="comment">// 记录结点是否有父节点，为了找根节点</span></span><br><span class="line"><span class="type">int</span> f[N][<span class="number">2</span>]; <span class="comment">// 列表示该结点选或不选</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	e[idx] = b;</span><br><span class="line">	ne[idx] = h[a];</span><br><span class="line">	h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	f[u][<span class="number">1</span>] = happy[u]; <span class="comment">// 选u点则加上u的快乐</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> j = e[i];</span><br><span class="line">		<span class="built_in">dfs</span>(j);</span><br><span class="line">		f[u][<span class="number">0</span>] += <span class="built_in">max</span>(f[j][<span class="number">0</span>], f[j][<span class="number">1</span>]); <span class="comment">// 自己不选，则子节点选不选都可以，挑最大值</span></span><br><span class="line">		f[u][<span class="number">1</span>] += f[j][<span class="number">0</span>]; <span class="comment">// 自己选了，子节点不能选了</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;happy[i]);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in">sizeof</span>(h));</span><br><span class="line">	<span class="type">int</span> a, b;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">		<span class="built_in">add</span>(b, a);</span><br><span class="line">		has_father[a] = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> root = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (has_father[root]) root++;</span><br><span class="line">	<span class="built_in">dfs</span>(root);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="built_in">max</span>(f[root][<span class="number">0</span>], f[root][<span class="number">1</span>]));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="！滑雪"><a href="#！滑雪" class="headerlink" title="！滑雪"></a>！滑雪</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 310;</span><br><span class="line">int n, m;</span><br><span class="line">int h[N][N];</span><br><span class="line">int f[N][N];</span><br><span class="line">int dx[4] = &#123; -1,0,1,0 &#125;, dy[4] = &#123; 0, -1, 0, 1 &#125;;</span><br><span class="line"></span><br><span class="line">int dp(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">	if (f[x][y] != -1) return f[x][y];</span><br><span class="line">	f[x][y] = 1;</span><br><span class="line">	for (int i = 0; i &lt; 4; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		int a = x + dx[i], b = y + dy[i];</span><br><span class="line">		if (a &gt;= 1 &amp;&amp; a &lt;= n &amp;&amp; b &gt;= 1 &amp;&amp; b &lt;= m &amp;&amp; h[a][b] &lt; h[x][y])</span><br><span class="line">		&#123;</span><br><span class="line">			f[x][y] = max(f[x][y], dp(a, b) + 1);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return f[x][y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	for (int i = 1; i &lt;= n; i++)</span><br><span class="line">		for (int j = 1; j &lt;= m; j++)</span><br><span class="line">			cin &gt;&gt; h[i][j]; </span><br><span class="line"></span><br><span class="line">	memset(f, -1, sizeof f);</span><br><span class="line">	int res = -1;</span><br><span class="line">	for(int i = 1; i &lt;= n; i++)</span><br><span class="line">		for (int j = 1; j &lt;= m; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			res = max(res, dp(i, j));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="计数问题"><a href="#计数问题" class="headerlink" title="计数问题"></a>计数问题</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">/*</span><br><span class="line">分情况讨论：</span><br><span class="line">abc d efg 中 x 出现的次数</span><br><span class="line">1 最高位取 001 - abc - 1 时, d = x, 000 - 999</span><br><span class="line">2.最高位取 abc</span><br><span class="line">    2.1 d &lt; x  无解：0</span><br><span class="line">    2.2 d = x  000 - efg  总共 efg + 1种</span><br><span class="line">    2.3 d &gt; x  000 - 999  总共 1000   种</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int get(vector&lt;int&gt; num, int l, int r)</span><br><span class="line">&#123;</span><br><span class="line">    int res = 0;</span><br><span class="line">    // n = 1234  num 4 3 2 1</span><br><span class="line">    // 注意因为 num 是倒序存储的各位数字，所以相当于是从后往前加</span><br><span class="line">    for (int i = l; i &gt;= r; i--)</span><br><span class="line">        res = res * 10 + num[i];</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 计算出 10 ^ x </span><br><span class="line">int power10(int x)</span><br><span class="line">&#123;</span><br><span class="line">    int res = 1;</span><br><span class="line">    while (x--) res *= 10;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int count(int n, int x)</span><br><span class="line">&#123;</span><br><span class="line">    if (!n) return 0;</span><br><span class="line">    // 用 vector 来倒序存储 n 例如 1423 存储的顺序是 3 2 4 1</span><br><span class="line">    vector&lt;int&gt; num;</span><br><span class="line">    while (n)</span><br><span class="line">    &#123;</span><br><span class="line">        num.push_back(n % 10);</span><br><span class="line">        n /= 10;</span><br><span class="line">    &#125;</span><br><span class="line">    // n 用来表示位数</span><br><span class="line">    n = num.size();</span><br><span class="line"></span><br><span class="line">    int res = 0;</span><br><span class="line">    // 从最高位 n - 1 开始判断，但是如果要判断的数是 0 的话，因为没有前导零，所以从第二位开始判断</span><br><span class="line">    for (int i = n - 1 - !x; i &gt;= 0; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        //判断当前位之前的情况，所以前置条件是当前判断位不能是最高位</span><br><span class="line">        if (i &lt; n - 1)</span><br><span class="line">        &#123;</span><br><span class="line">            // 第 1 种情况</span><br><span class="line">            res += get(num, n - 1, i + 1) * power10(i);</span><br><span class="line">            // 特殊情况当 x = 0 时，不能有连续前导0，所以要去除 000 的情况</span><br><span class="line">            if (!x) res -= power10(i);</span><br><span class="line">        &#125;</span><br><span class="line">        // 2.1 种情况无解已经省略</span><br><span class="line">        // 2.2 d == x</span><br><span class="line">        if (num[i] == x) res += get(num, i - 1, 0) + 1;</span><br><span class="line">        // 2.3 d &gt; x</span><br><span class="line">        else if (num[i] &gt; x) res += power10(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a, b;</span><br><span class="line">    while (cin &gt;&gt; a &gt;&gt; b, a || b)</span><br><span class="line">    &#123;</span><br><span class="line">        if (a &gt; b) swap(a, b);</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 10; i++)</span><br><span class="line">            cout &lt;&lt; count(b, i) - count(a - 1, i) &lt;&lt; &#x27; &#x27;;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="最长上升子序列II"><a href="#最长上升子序列II" class="headerlink" title="最长上升子序列II"></a>最长上升子序列II</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 100010;</span><br><span class="line"></span><br><span class="line">int n;</span><br><span class="line">// q数组中元素是单调递增的(因为如果第r+1个元素小于第r个元素，则必然存在长度为r的序列结尾值比该第r个元素小)</span><br><span class="line">// q数组中存储最长子序列结尾值最小的那个点</span><br><span class="line">int a[N], q[N]; </span><br><span class="line"></span><br><span class="line">// 思想确定右端点后，找前面最长子序列结尾值最小的那个点</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">	for (int i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">	int len = 0;</span><br><span class="line">	q[0] = -2e9;</span><br><span class="line">	for (int i = 0; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		// 用二分来将a[i]插入q[i]中</span><br><span class="line">		int l = 0, r = len;</span><br><span class="line">		while (l &lt; r)</span><br><span class="line">		&#123;</span><br><span class="line">			int mid = l + r + 1 &gt;&gt; 1;</span><br><span class="line">			if (q[mid] &lt; a[i]) l = mid;</span><br><span class="line">			else r = mid - 1;</span><br><span class="line">		&#125;</span><br><span class="line">		// len的长度即q数组的元素个数</span><br><span class="line">		len = max(len, r + 1);</span><br><span class="line">		// 说明a[i]大于q[r]但是同时小于q[r+1],故更新q[r+1],q[r+1]的值表示最长子序列为r+1的结尾值最小的数</span><br><span class="line">		q[r + 1] = a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;%d\n&quot;, len);</span><br><span class="line">	return 0;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="最短编辑距离"><a href="#最短编辑距离" class="headerlink" title="最短编辑距离"></a>最短编辑距离</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1010;</span><br><span class="line"></span><br><span class="line">int n, m;</span><br><span class="line">char a[N], b[N];</span><br><span class="line">int f[N][N];</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	scanf(&quot;%d%s&quot;, &amp;n, a + 1);</span><br><span class="line">	scanf(&quot;%d%s&quot;, &amp;m, b + 1);</span><br><span class="line"></span><br><span class="line">	for (int i = 0; i &lt;= m; i++) f[0][i] = i;</span><br><span class="line">	for (int i = 0; i &lt;= m; i++) f[i][0] = i;</span><br><span class="line"></span><br><span class="line">	for(int i = 1; i &lt;= n; i++)</span><br><span class="line">		for (int j = 1; j &lt;= m; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			f[i][j] = min(f[i - 1][j] + 1, f[i][j - 1] + 1);</span><br><span class="line">			if (a[i] == b[j]) f[i][j] = min(f[i][j], f[i - 1][j - 1]);</span><br><span class="line">			else f[i][j] = min(f[i][j], f[i - 1][j - 1] + 1);</span><br><span class="line">		&#125;</span><br><span class="line">	printf(&quot;%d\n&quot;, f[n][m]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="整数划分"><a href="#整数划分" class="headerlink" title="整数划分"></a>整数划分</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1010, mod = 1e9 + 7;</span><br><span class="line">int n;</span><br><span class="line">int f[N];</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	f[0] = 1;</span><br><span class="line">	for (int i = 1; i &lt;= n; i++)</span><br><span class="line">		for (int j = i; j &lt;= n; j++)</span><br><span class="line">			f[j] = (f[j] + f[j - i]) % mod;</span><br><span class="line">	cout &lt;&lt; f[n] &lt;&lt; endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="区间选点"><a href="#区间选点" class="headerlink" title="区间选点"></a>区间选点</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 100010;</span><br><span class="line">int n;</span><br><span class="line">struct Range</span><br><span class="line">&#123;</span><br><span class="line">	int l, r;</span><br><span class="line">	bool operator&lt; (const Range&amp; W) const</span><br><span class="line">	&#123;</span><br><span class="line">		return r &lt; W.r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;range[N];</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">	for (int i = 0; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		int l, r;</span><br><span class="line">		scanf(&quot;%d%d&quot;, &amp;l, &amp;r);</span><br><span class="line">		range[i] = &#123; l,r &#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sort(range, range + n);</span><br><span class="line">	int res = 0, ed = -2e9;</span><br><span class="line">	for (int i = 0; i &lt; n; i++)</span><br><span class="line">		if (range[i].l &gt; ed)</span><br><span class="line">		&#123;</span><br><span class="line">			res++;</span><br><span class="line">			ed = range[i].r;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	printf(&quot;%d\n&quot;, res);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="区间分组"><a href="#区间分组" class="headerlink" title="区间分组"></a>区间分组</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 100010;</span><br><span class="line">int n;</span><br><span class="line">struct Range</span><br><span class="line">&#123;</span><br><span class="line">	int l, r;</span><br><span class="line">	bool operator&lt; (const Range&amp; W) const</span><br><span class="line">	&#123;</span><br><span class="line">		return l &lt; W.l;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;range[N];</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">	for (int i = 0; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		int l, r;</span><br><span class="line">		scanf(&quot;%d%d&quot;, &amp;l, &amp;r);</span><br><span class="line">		range[i] = &#123; l,r &#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sort(range, range + n);</span><br><span class="line">	</span><br><span class="line">	priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt;heap;</span><br><span class="line">	for (int i = 0; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		auto r = range[i];</span><br><span class="line">		if (heap.empty() || heap.top() &gt;= r.l) heap.push(r.r);</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			heap.pop();</span><br><span class="line">			heap.push(r.r);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	printf(&quot;%d\n&quot;, heap.size());</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="区间覆盖"><a href="#区间覆盖" class="headerlink" title="区间覆盖"></a>区间覆盖</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 100010;</span><br><span class="line">int n;</span><br><span class="line">struct Range</span><br><span class="line">&#123;</span><br><span class="line">	int l, r;</span><br><span class="line">	bool operator&lt; (const Range&amp; W) const</span><br><span class="line">	&#123;</span><br><span class="line">		return l &lt; W.l;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;range[N];</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int st, ed;</span><br><span class="line">	scanf(&quot;%d%d&quot;, &amp;st, &amp;ed);</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">	for (int i = 0; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		int l, r;</span><br><span class="line">		scanf(&quot;%d%d&quot;, &amp;l, &amp;r);</span><br><span class="line">		range[i] = &#123; l,r &#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sort(range, range + n);</span><br><span class="line">	</span><br><span class="line">	int res = 0;</span><br><span class="line">	for (int i = 0; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		int j = i, r = -2e9;</span><br><span class="line">		while (j &lt; n &amp;&amp; range[j].l &lt;= st)</span><br><span class="line">		&#123;</span><br><span class="line">			r = max(r, range[j].r);</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">		if (r &lt; st)</span><br><span class="line">		&#123;</span><br><span class="line">			res = -1;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		res++;</span><br><span class="line">		if (r &gt;= ed)</span><br><span class="line">		&#123;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		st = r;</span><br><span class="line">		i = j - 1;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;%d\n&quot;, res);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="合并果子"><a href="#合并果子" class="headerlink" title="合并果子"></a>合并果子</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int n;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; heap;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">	while (n--)</span><br><span class="line">	&#123;</span><br><span class="line">		int x;</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;x);</span><br><span class="line">		heap.push(x);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	int res = 0;</span><br><span class="line">	while (heap.size() &gt; 1)</span><br><span class="line">	&#123;</span><br><span class="line">		int a = heap.top(); heap.pop();</span><br><span class="line">		int b = heap.top(); heap.pop();</span><br><span class="line">		heap.push(a + b);</span><br><span class="line">		res += a + b;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;%d\n&quot;, res);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="排队打水"><a href="#排队打水" class="headerlink" title="排队打水"></a>排队打水</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef long long LL;</span><br><span class="line"></span><br><span class="line">const int N = 100010;</span><br><span class="line"></span><br><span class="line">int n;</span><br><span class="line">int t[N];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">	for (int i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;t[i]);</span><br><span class="line"></span><br><span class="line">	sort(t, t + n);</span><br><span class="line"></span><br><span class="line">	LL res = 0;</span><br><span class="line">	for (int i = 0; i &lt; n; i++) res += t[i] * (n - i - 1);</span><br><span class="line"></span><br><span class="line">	printf(&quot;%lld\n&quot;, res);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="货仓选址"><a href="#货仓选址" class="headerlink" title="货仓选址"></a>货仓选址</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 100010;</span><br><span class="line"></span><br><span class="line">int n;</span><br><span class="line">int a[N];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">	for (int i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">	sort(a, a + n);</span><br><span class="line"></span><br><span class="line">	int res = 0;</span><br><span class="line">	for (int i = 0; i &lt; n; i++) res += abs(a[i] - a[n / 2]);</span><br><span class="line"></span><br><span class="line">	printf(&quot;%d\n&quot;, res);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="耍杂技的牛"><a href="#耍杂技的牛" class="headerlink" title="耍杂技的牛"></a>耍杂技的牛</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 50010;</span><br><span class="line"></span><br><span class="line">typedef pair&lt;int, int&gt; PII;</span><br><span class="line">int n;</span><br><span class="line">PII cow[N];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">	for (int i = 0; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		int w, s;</span><br><span class="line">		scanf(&quot;%d%d&quot;, &amp;w, &amp;s);</span><br><span class="line">		cow[i] = &#123; w + s, w &#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(cow, cow + n);</span><br><span class="line">	int res = -2e9, sum = 0;</span><br><span class="line">	for (int i = 0; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		int w = cow[i].second, s = cow[i].first - w;</span><br><span class="line">		res = max(res, sum - s);</span><br><span class="line">		sum += w;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;%d\n&quot;, res);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="！排列数字"><a href="#！排列数字" class="headerlink" title="！排列数字"></a>！排列数字</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 10;</span><br><span class="line">int n;</span><br><span class="line">int path[N];</span><br><span class="line">bool st[N];</span><br><span class="line"></span><br><span class="line">void dfs(int u)</span><br><span class="line">&#123;</span><br><span class="line">    if(u == n)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i = 0; i &lt; n; i++) printf(&quot;%d &quot;,path[i]);</span><br><span class="line">        puts(&quot;&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 1; i &lt;= n; i++)</span><br><span class="line">        if(!st[i])</span><br><span class="line">        &#123;</span><br><span class="line">            path[u] = i;</span><br><span class="line">            st[i] = true;</span><br><span class="line">            dfs(u + 1);</span><br><span class="line">            st[i] = false; // 还原现场</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    dfs(0);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="！n-皇后问题"><a href="#！n-皇后问题" class="headerlink" title="！n-皇后问题"></a>！n-皇后问题</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 20;</span><br><span class="line"></span><br><span class="line">int n;</span><br><span class="line">char g[N][N];</span><br><span class="line">bool col[N], dg[N], udg[N]; // dg是主对角线，udg是反对角线</span><br><span class="line"></span><br><span class="line">void dfs(int u)</span><br><span class="line">&#123;</span><br><span class="line">    if (u == n)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i = 0; i &lt; n; i++) puts(g[i]);</span><br><span class="line">        puts(&quot;&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i = 0; i &lt; n; i++)</span><br><span class="line">        if (!col[i] &amp;&amp; !dg[u + i] &amp;&amp; !udg[n - u + i]) // udg是u-i的值一样即可，但由于u-i可能为负数，所以需要加上偏移量n</span><br><span class="line">        &#123;</span><br><span class="line">            g[u][i] = &#x27;Q&#x27;;</span><br><span class="line">            col[i] = dg[u + i] = udg[n - u + i] = true;</span><br><span class="line">            dfs(u + 1);</span><br><span class="line">            // 还原现场</span><br><span class="line">            col[i] = dg[u + i] = udg[n- u + i] = false;</span><br><span class="line">            g[u][i] = &#x27;.&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    for(int i = 0; i &lt; n; i++)</span><br><span class="line">        for(int j = 0; j &lt; n; j++)</span><br><span class="line">            g[i][j] = &#x27;.&#x27;;</span><br><span class="line">    </span><br><span class="line">    dfs(0);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="走迷宫"><a href="#走迷宫" class="headerlink" title="走迷宫"></a>走迷宫</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef pair&lt;int,int&gt; PII;</span><br><span class="line">const int N = 110;</span><br><span class="line"></span><br><span class="line">int n,m;</span><br><span class="line">int g[N][N]; // 存储该位置是否为通路</span><br><span class="line">int d[N][N]; // -1表示该位置没走过，存储该位置最早是第几次走过</span><br><span class="line">PII q[N * N], Prev[N][N]; // Prev中存储该点上一次走过的点</span><br><span class="line"></span><br><span class="line">int bfs()</span><br><span class="line">&#123;</span><br><span class="line">    int hh = 0, tt = 0;</span><br><span class="line">    q[0] = &#123;0,0&#125;;</span><br><span class="line"></span><br><span class="line">    memset(d,-1,sizeof d);</span><br><span class="line">    d[0][0] = 0;</span><br><span class="line"></span><br><span class="line">    int dx[4] = &#123;-1, 0, 1, 0&#125;,dy[4] = &#123;0, 1, 0, -1&#125;; // 代表四个方位</span><br><span class="line"></span><br><span class="line">    while(hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        auto t = q[hh ++ ];// 存储出队的元素</span><br><span class="line"></span><br><span class="line">        for(int i = 0; i &lt; 4; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int x = t.first + dx[i], y = t.second + dy[i];</span><br><span class="line">            if(x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m &amp;&amp; g[x][y] == 0 &amp;&amp; d[x][y] == -1)</span><br><span class="line">            &#123;</span><br><span class="line">                d[x][y] = d[t.first][t.second] + 1;</span><br><span class="line">                Prev[x][y] = t;</span><br><span class="line">                q[ ++ tt] = &#123;x,y&#125;;	</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int x = n - 1, y = m - 1;</span><br><span class="line">    while(x || y)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; &#x27; &#x27; &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">        auto t = Prev[x][y];</span><br><span class="line">        x = t.first, y = t.second;</span><br><span class="line">    &#125;</span><br><span class="line">    return d[n - 1][m - 1];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    for(int i = 0; i &lt; n; i++)</span><br><span class="line">        for(int j = 0; j &lt; m; j++)</span><br><span class="line">        cin &gt;&gt; g[i][j];</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; bfs() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="树的重心"><a href="#树的重心" class="headerlink" title="树的重心"></a>树的重心</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 100010, M = N * 2;</span><br><span class="line"></span><br><span class="line">int n;</span><br><span class="line">int h[N], e[M], ne[M], idx;</span><br><span class="line">bool st[N];</span><br><span class="line"></span><br><span class="line">int ans = N;</span><br><span class="line"></span><br><span class="line">void add(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int dfs(int u)</span><br><span class="line">&#123;</span><br><span class="line">    st[u] = true; // 标记一下，已经搜过了</span><br><span class="line">    int sum = 1, res = 0;</span><br><span class="line">    for(int i = h[u]; i != -1; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        int j = e[i];</span><br><span class="line">        if (!st[j])</span><br><span class="line">        &#123;</span><br><span class="line">            int s = dfs(j);</span><br><span class="line">            res = max(res, s);</span><br><span class="line">            sum += s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res = max(res, n - sum);</span><br><span class="line">    ans = min(ans, res);</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    memset(h, -1, sizeof h);</span><br><span class="line">    for (int i = 0; i &lt; n - 1; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int a,b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        add(a,b), add(b,a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs(1);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="图中点的层次"><a href="#图中点的层次" class="headerlink" title="图中点的层次"></a>图中点的层次</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 100010;</span><br><span class="line"></span><br><span class="line">int n, m;</span><br><span class="line">int h[N], e[N], ne[N], idx;</span><br><span class="line">int d[N], q[N];</span><br><span class="line"></span><br><span class="line">void add(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int bfs()</span><br><span class="line">&#123;</span><br><span class="line">    int hh = 0, tt = 0;</span><br><span class="line">    q[0] = 1;</span><br><span class="line">    memset(d, -1, sizeof d);</span><br><span class="line">    d[1] = 0;</span><br><span class="line">    while(hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        int t = q[hh++];</span><br><span class="line"></span><br><span class="line">        for(int i = h[t]; i != -1; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            int j = e[i];</span><br><span class="line">            if(d[j] == -1)</span><br><span class="line">            &#123;</span><br><span class="line">                d[j] = d[t] + 1;</span><br><span class="line">                q[ ++ tt] = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return d[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    memset(h, -1, sizeof h);</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        add(a, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; bfs() &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="！有向图的拓扑序列"><a href="#！有向图的拓扑序列" class="headerlink" title="！有向图的拓扑序列"></a>！有向图的拓扑序列</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 100010;</span><br><span class="line"></span><br><span class="line">int n, m;</span><br><span class="line">int h[N], e[N], ne[N], idx;</span><br><span class="line">int d[N], q[N]; // d中存储该点的入度</span><br><span class="line"></span><br><span class="line">void add(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool topsort()</span><br><span class="line">&#123;</span><br><span class="line">    int hh = 0, tt = -1;</span><br><span class="line"></span><br><span class="line">    for(int i = 1; i &lt;= n; i++)</span><br><span class="line">        if(!d[i]) // 将入读为0的点存入拓扑序列中</span><br><span class="line">            q[ ++ tt] = i;</span><br><span class="line">    </span><br><span class="line">    while(hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        int t = q[hh ++];</span><br><span class="line"></span><br><span class="line">        for(int i = h[t]; i != -1; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            int j = e[i];</span><br><span class="line">            d[j] --; // 将t点指向的结点的入度减1</span><br><span class="line">            if(d[j] == 0) q[ ++ tt] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;	</span><br><span class="line"></span><br><span class="line">    return tt == n - 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    memset(h, -1, sizeof h);</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        add(a, b);</span><br><span class="line">        d[b] ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (topsort())</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) printf(&quot;%d &quot;, q[i]);</span><br><span class="line">        puts(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else puts(&quot;-1&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="！Dijkstra求最短路I"><a href="#！Dijkstra求最短路I" class="headerlink" title="！Dijkstra求最短路I"></a>！Dijkstra求最短路I</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">	dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> t = <span class="number">-1</span>; <span class="comment">// 判断每轮的距离最小的结点是哪个</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">			<span class="keyword">if</span>(!st[j] &amp;&amp; (t==<span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">				t = j;</span><br><span class="line"></span><br><span class="line">		st[t] = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">			dist[j] = <span class="built_in">min</span>(dist[j], dist[t] + g[t][j]); <span class="comment">// 更新其他点到源点的距离</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (m--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> a, b, c;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a, &amp;b, &amp;c);</span><br><span class="line">		g[a][b] = <span class="built_in">min</span>(g[a][b], c);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> t = <span class="built_in">dijkstra</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, t);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="！Dijkstra求最短路II"><a href="#！Dijkstra求最短路II" class="headerlink" title="！Dijkstra求最短路II"></a>！Dijkstra求最短路II</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef pair&lt;int, int&gt; PII;</span><br><span class="line">const int N = 510;</span><br><span class="line"></span><br><span class="line">int n, m, idx;</span><br><span class="line">int h[N], w[N], e[N], ne[N];</span><br><span class="line">int dist[N];</span><br><span class="line">bool st[N];</span><br><span class="line">void add(int a, int b, int c)</span><br><span class="line">&#123;</span><br><span class="line">	e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int dijkstra()</span><br><span class="line">&#123;</span><br><span class="line">	memset(dist, 0x3f, sizeof dist);</span><br><span class="line">	dist[1] = 0;</span><br><span class="line"></span><br><span class="line">	priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;</span><br><span class="line">	heap.push(&#123;0,1&#125;);</span><br><span class="line"></span><br><span class="line">	while (heap.size())</span><br><span class="line">	&#123;</span><br><span class="line">		auto t = heap.top();</span><br><span class="line">		heap.pop();</span><br><span class="line"></span><br><span class="line">		int ver = t.second, distance = t.first;</span><br><span class="line">		if(st[ver]) continue;</span><br><span class="line">		st[ver] = true;</span><br><span class="line">		for (int i = h[ver]; i != -1; i = ne[i])</span><br><span class="line">		&#123;</span><br><span class="line">			int j = e[i];</span><br><span class="line">			if(dist[j] &gt; distance + w[i])</span><br><span class="line">			&#123;</span><br><span class="line">				dist[j] = distance + w[i];</span><br><span class="line">				heap.push(&#123;dist[j], j&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if(dist[n] == 0x3f3f3f3f) return -1;</span><br><span class="line">	return dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">	memset(h, -1, sizeof h);</span><br><span class="line"></span><br><span class="line">	while (m--)</span><br><span class="line">	&#123;</span><br><span class="line">		int a, b, c;</span><br><span class="line">		scanf(&quot;%d%d%d&quot;,&amp;a, &amp;b, &amp;c);</span><br><span class="line">		add(a, b, c);	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	int t = dijkstra();</span><br><span class="line"></span><br><span class="line">	printf(&quot;%d\n&quot;, t);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="有边数限制的最短路"><a href="#有边数限制的最短路" class="headerlink" title="有边数限制的最短路"></a>有边数限制的最短路</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 510, M = 10010;</span><br><span class="line"></span><br><span class="line">int n, m, k;</span><br><span class="line">int dist[N], backup[N]; // backup是上一次更新的结果</span><br><span class="line"></span><br><span class="line">struct Edge</span><br><span class="line">&#123;</span><br><span class="line">	int a, b, w;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line">int bellman_ford()</span><br><span class="line">&#123;</span><br><span class="line">	memset(dist, 0x3f, sizeof dist);</span><br><span class="line">	dist[1] = 0;</span><br><span class="line"></span><br><span class="line">	for (int i = 0; i &lt; k; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		memcpy(backup, dist, sizeof dist);</span><br><span class="line">		for (int j = 0; j &lt; m; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			int a = edges[j].a, b = edges[j].b, w = edges[j].w;</span><br><span class="line">			dist[b] = min(dist[b], backup[a] + w);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if(dist[n] &gt; 0x3f3f3f3f / 2) return -1;</span><br><span class="line">	return dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k);</span><br><span class="line"></span><br><span class="line">	for(int i = 0; i &lt; m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		int a, b, w;</span><br><span class="line">		scanf(&quot;%d%d%d&quot;,&amp;a, &amp;b, &amp;w);</span><br><span class="line">		edges[i] = &#123;a, b, w&#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	int t = bellman_ford();</span><br><span class="line"></span><br><span class="line">	if(t == -1) puts(&quot;impossible&quot;);</span><br><span class="line">	else printf(&quot;%d\n&quot;, t);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="spfa求最短路"><a href="#spfa求最短路" class="headerlink" title="spfa求最短路"></a>spfa求最短路</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef pair&lt;int, int&gt; PII;</span><br><span class="line"></span><br><span class="line">const int N = 100010;</span><br><span class="line"></span><br><span class="line">int n, m;</span><br><span class="line">int h[N], w[N], e[N], ne[N], idx;</span><br><span class="line">int dist[N];</span><br><span class="line">bool st[N];</span><br><span class="line"></span><br><span class="line">void add(int a, int b, int c)</span><br><span class="line">&#123;</span><br><span class="line">	e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int spfa()</span><br><span class="line">&#123;</span><br><span class="line">	memset(dist, 0x3f, sizeof dist);</span><br><span class="line">	dist[1] = 0;</span><br><span class="line"></span><br><span class="line">	queue&lt;int&gt; q;</span><br><span class="line">	q.push(1);</span><br><span class="line">	st[1] = true;</span><br><span class="line"></span><br><span class="line">	while (q.size())</span><br><span class="line">	&#123;</span><br><span class="line">		int t = q.front();</span><br><span class="line">		q.pop();</span><br><span class="line"></span><br><span class="line">		st[t] = false;</span><br><span class="line"></span><br><span class="line">		for(int i = h[t]; i != -1; i = ne[i])</span><br><span class="line">		&#123;</span><br><span class="line">			int j = e[i];</span><br><span class="line">			if(dist[j] &gt; dist[t] + w[i])</span><br><span class="line">			&#123;</span><br><span class="line">				dist[j] = dist[t] + w[i];</span><br><span class="line">				if (!st[j])</span><br><span class="line">				&#123;</span><br><span class="line">					q.push(j);</span><br><span class="line">					st[j] = false;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (dist[n] == 0x3f3f3f3f) return -1;</span><br><span class="line">	return dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	scanf(&quot;%d%d&quot;,&amp;n, &amp;m);</span><br><span class="line">	memset(h, -1, sizeof h);</span><br><span class="line"></span><br><span class="line">	while (m--)</span><br><span class="line">	&#123;</span><br><span class="line">		int a, b, c;</span><br><span class="line">		scanf(&quot;%d%d%d&quot;,&amp;a, &amp;b, &amp;c);</span><br><span class="line">		add(a, b, c);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	int t = spfa();</span><br><span class="line"></span><br><span class="line">	if(t == -1) puts(&quot;impossible&quot;);</span><br><span class="line">	else printf(&quot;%d\n&quot;, t);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="！floyd求最短路"><a href="#！floyd求最短路" class="headerlink" title="！floyd求最短路"></a>！floyd求最短路</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 210, INF = 1e9;</span><br><span class="line"></span><br><span class="line">int n, m, Q;</span><br><span class="line">int d[N][N];</span><br><span class="line"></span><br><span class="line">void floyd()</span><br><span class="line">&#123;</span><br><span class="line">	for(int k = 1; k &lt;= n; k++)</span><br><span class="line">		for(int i = 1; i &lt;= n; i++)</span><br><span class="line">			for(int j = 1; j &lt;= n; j++)</span><br><span class="line">				d[i][j] = min(d[i][j], d[i][k] + d[k][j]);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;Q);</span><br><span class="line">	for(int i = 1; i &lt;= n; i++)</span><br><span class="line">		for(int j = 1; j &lt;= n; j++)</span><br><span class="line">			if(i == j) d[i][j] = 0;</span><br><span class="line">			else d[i][j] = INF;</span><br><span class="line"></span><br><span class="line">	while (m--)</span><br><span class="line">	&#123;</span><br><span class="line">		int a, b, w;</span><br><span class="line">		scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;w);</span><br><span class="line"></span><br><span class="line">		d[a][b] = min(d[a][b], w);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	floyd();</span><br><span class="line"></span><br><span class="line">	while (Q--)</span><br><span class="line">	&#123;</span><br><span class="line">		int a, b;</span><br><span class="line">		scanf(&quot;%d%d&quot;, &amp;a, &amp;b);</span><br><span class="line"></span><br><span class="line">		if(d[a][b] &gt; INF/2) puts(&quot;impossible&quot;);</span><br><span class="line">		else printf(&quot;%d\n&quot;, d[a][b]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="！Prim算法求最小生成树"><a href="#！Prim算法求最小生成树" class="headerlink" title="！Prim算法求最小生成树"></a>！Prim算法求最小生成树</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 510, INF = 0x3f3f3f3f;</span><br><span class="line">int g[N][N];</span><br><span class="line">int dist[N];</span><br><span class="line">bool st[N];</span><br><span class="line">int n, m, res;</span><br><span class="line"></span><br><span class="line">int prim()</span><br><span class="line">&#123;</span><br><span class="line">	res = 0;</span><br><span class="line">	for (int i = 0; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		int t = -1;</span><br><span class="line">		for (int j = 1; j &lt;= n; j++)</span><br><span class="line">			if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j]))</span><br><span class="line">				t = j;</span><br><span class="line"></span><br><span class="line">		if (i &amp;&amp; dist[t] == INF) return INF;</span><br><span class="line">		if (i) res += dist[t];</span><br><span class="line"></span><br><span class="line">		for (int j = 1; j &lt;= n; j++)dist[j] = min(dist[j], g[t][j]);</span><br><span class="line"></span><br><span class="line">		st[t] = true;</span><br><span class="line">	&#125;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><span class="line">	memset(g, 0x3f, sizeof g);</span><br><span class="line">	memset(dist, 0x3f, sizeof dist);</span><br><span class="line">	while (m--)</span><br><span class="line">	&#123;</span><br><span class="line">		int a, b, c;</span><br><span class="line">		scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);</span><br><span class="line">		g[a][b] = g[b][a] = min(g[a][b], c);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	int t = prim();</span><br><span class="line">	if (t == INF) printf(&quot;impossible\n&quot;);</span><br><span class="line">	else printf(&quot;%d\n&quot;, res);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Kruskal算法求最小生成树"><a href="#Kruskal算法求最小生成树" class="headerlink" title="Kruskal算法求最小生成树"></a>Kruskal算法求最小生成树</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 2e5 + 10, INF = 0x3f3f3f3f;</span><br><span class="line">int p[N];</span><br><span class="line">int n, m;</span><br><span class="line"></span><br><span class="line">struct Edge</span><br><span class="line">&#123;</span><br><span class="line">	int a, b, w;</span><br><span class="line">	bool operator &lt; (const Edge&amp; t) const</span><br><span class="line">	&#123;</span><br><span class="line">		return w &lt; t.w;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;edge[N];</span><br><span class="line"></span><br><span class="line">int find(int x)</span><br><span class="line">&#123;</span><br><span class="line">	if (p[x] != x) p[x] = find(p[x]);</span><br><span class="line">	return p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int kruskal()</span><br><span class="line">&#123;</span><br><span class="line">	sort(edge, edge + m);</span><br><span class="line">	</span><br><span class="line">	int res = 0, cnt = 0;</span><br><span class="line">	for (int i = 0; i &lt; m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		auto e = edge[i];</span><br><span class="line">		int a = e.a, b = e.b, w = e.w;</span><br><span class="line">		a = find(a), b = find(b);</span><br><span class="line">		if (a != b)</span><br><span class="line">		&#123;</span><br><span class="line">			res += w;</span><br><span class="line">			cnt++;</span><br><span class="line">			p[a] = b;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if (cnt != n - 1) return INF;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">	for (int i = 0; i &lt; m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		int a, b, w;</span><br><span class="line">		scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;w);</span><br><span class="line">		edge[i] = &#123; a,b,w &#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for (int i = 1; i &lt;= n; i++) p[i] = i;</span><br><span class="line"></span><br><span class="line">	int t = kruskal();</span><br><span class="line">	if (t == INF) puts(&quot;impossible&quot;);</span><br><span class="line">	else printf(&quot;%d\n&quot;, t);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="染色法判定二分图"><a href="#染色法判定二分图" class="headerlink" title="染色法判定二分图"></a>染色法判定二分图</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 100010, M = 200010;</span><br><span class="line">int n, m;</span><br><span class="line">int h[N], e[M], ne[M], idx;</span><br><span class="line">int color[N];</span><br><span class="line"></span><br><span class="line">void add(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">	e[idx] = b, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool dfs(int u, int c)</span><br><span class="line">&#123;</span><br><span class="line">	color[u] = c;</span><br><span class="line"></span><br><span class="line">	for (int i = h[u]; i != -1; i = ne[i])</span><br><span class="line">	&#123;</span><br><span class="line">		int j = e[i];</span><br><span class="line">		if (!color[j])</span><br><span class="line">		&#123;</span><br><span class="line">			if (!dfs(j, 3 - c)) return false;</span><br><span class="line">		&#125;	</span><br><span class="line">		else if (color[j] == c) return false;</span><br><span class="line">	&#125;</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><span class="line">	memset(h, -1, sizeof h);</span><br><span class="line"></span><br><span class="line">	while (m--)</span><br><span class="line">	&#123;</span><br><span class="line">		int a, b;</span><br><span class="line">		scanf(&quot;%d%d&quot;, &amp;a, &amp;b);</span><br><span class="line">		add(a, b), add(b, a);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	bool flag = true;</span><br><span class="line">	for (int i = 1; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if (!color[i])</span><br><span class="line">		&#123;</span><br><span class="line">			if (!dfs(i, 1))</span><br><span class="line">			&#123;</span><br><span class="line">				flag = false;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (flag) puts(&quot;Yes&quot;);</span><br><span class="line">	else puts(&quot;No&quot;);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二分图的最大匹配"><a href="#二分图的最大匹配" class="headerlink" title="二分图的最大匹配"></a>二分图的最大匹配</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 510, M = 100010;</span><br><span class="line"></span><br><span class="line">int n1, n2, m;</span><br><span class="line">int h[N], e[M], ne[M], idx;</span><br><span class="line">int match[N];</span><br><span class="line">bool st[N];</span><br><span class="line"></span><br><span class="line">void add(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">	e[idx] = b, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool find(int x)</span><br><span class="line">&#123;</span><br><span class="line">	for (int i = h[x]; i != -1; i = ne[i])</span><br><span class="line">	&#123;</span><br><span class="line">		int j = e[i];</span><br><span class="line">		if (!st[j])</span><br><span class="line">		&#123;</span><br><span class="line">			st[j] = true;</span><br><span class="line">			if (match[j] == 0 || find(match[j]))</span><br><span class="line">			&#123;</span><br><span class="line">				match[j] = x;</span><br><span class="line">				return true;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	scanf(&quot;%d%d%d&quot;, &amp;n1, &amp;n2, &amp;m);</span><br><span class="line"></span><br><span class="line">	memset(h, -1, sizeof h);</span><br><span class="line"></span><br><span class="line">	while (m--)</span><br><span class="line">	&#123;</span><br><span class="line">		int a, b;</span><br><span class="line">		scanf(&quot;%d%d&quot;, &amp;a, &amp;b);</span><br><span class="line">		add(a, b);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	int res = 0;</span><br><span class="line">	for (int i = 1; i &lt;= n1; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		memset(st, false, sizeof st);</span><br><span class="line">		if (find(i)) res++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	printf(&quot;%d\n&quot;, res);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">每个位置c[i] = A[i - 2^k + 1] + A[i - 2^k + 2] +...+ A[i];</span><br><span class="line">求和前7项和，sum = c[7] + c[6] + c[4];</span><br><span class="line">sumi = c[i] + c[i - 2^k1] + c[(i - 2^k1) - 2^k2] + ...;</span><br><span class="line">2^k = i&amp;(-i);//求从右往左的第一个1加上后面0的值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int n;</span><br><span class="line"> int a[1005],c[1005]; //对应原数组和树状数组</span><br><span class="line"> </span><br><span class="line"> int lowbit(int x)&#123;</span><br><span class="line">     return x&amp;(-x);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> void updata(int i,int k)&#123;    //在i位置加上k</span><br><span class="line">     while(i &lt;= n)&#123;</span><br><span class="line">         c[i] += k;</span><br><span class="line">         i += lowbit(i);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> int getsum(int i)&#123;        //求A[1 - i]的和</span><br><span class="line">     int res = 0;</span><br><span class="line">     while(i &gt; 0)&#123;</span><br><span class="line">         res += c[i];</span><br><span class="line">         i -= lowbit(i);</span><br><span class="line">     &#125;</span><br><span class="line">     return res;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h1 id="莫队算法-重复的数"><a href="#莫队算法-重复的数" class="headerlink" title="莫队算法(重复的数)"></a>莫队算法(重复的数)</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 1e5 + 10;</span><br><span class="line">int a[N], cnt[N], res[N], mp[N];</span><br><span class="line"></span><br><span class="line">int n, m, len;</span><br><span class="line"></span><br><span class="line">struct tt</span><br><span class="line">&#123;</span><br><span class="line">	int l, r, pos, k;</span><br><span class="line">	bool operator &lt;(const struct tt&amp; t)const</span><br><span class="line">	&#123;</span><br><span class="line">		if (l / len == t.l / len) return r &lt; t.r;</span><br><span class="line">		else return l / len &lt; t.l / len;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;ask[N];</span><br><span class="line"></span><br><span class="line">void sub(int n)</span><br><span class="line">&#123;</span><br><span class="line">	mp[cnt[a[n]]]--;</span><br><span class="line">	cnt[a[n]]--;</span><br><span class="line">	mp[cnt[a[n]]]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void add(int n)</span><br><span class="line">&#123;</span><br><span class="line">	mp[cnt[a[n]]]--;</span><br><span class="line">	cnt[a[n]]++;</span><br><span class="line">	mp[cnt[a[n]]]++;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	len = pow(n, 0.5);</span><br><span class="line">	for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i];</span><br><span class="line">	cin &gt;&gt; m;</span><br><span class="line">	for (int i = 1; i &lt;= m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		scanf(&quot;%d%d%d&quot;, &amp;ask[i].l, &amp;ask[i].r, &amp;ask[i].k);</span><br><span class="line">		ask[i].pos = i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sort(ask + 1, ask + 1 + n);</span><br><span class="line"></span><br><span class="line">	int l = 1, r = 0;</span><br><span class="line">	for (int i = 1; i &lt;= m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		while (l &lt; ask[i].l) sub(l++);</span><br><span class="line">		while (l &gt; ask[i].l) add(--l);</span><br><span class="line">		while (r &lt; ask[i].r) add(++r);</span><br><span class="line">		while (r &gt; ask[i].r) sub(r--);</span><br><span class="line">		res[ask[i].pos] = mp[ask[i].k];</span><br><span class="line">	&#125;</span><br><span class="line">	for (int i = 1; i &lt;= m; i++)</span><br><span class="line">		cout &lt;&lt; res[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h1><h2 id="第一版"><a href="#第一版" class="headerlink" title="第一版"></a>第一版</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1e5 + 10;</span><br><span class="line">int arr[] = &#123; 1, 3, 5, 7, 9, 11 &#125;;</span><br><span class="line">int tree[N];</span><br><span class="line">int Size = 6;</span><br><span class="line"></span><br><span class="line">void build_tree(int node, int start, int end)</span><br><span class="line">&#123;</span><br><span class="line">	if (start == end)</span><br><span class="line">	&#123;</span><br><span class="line">		tree[node] = arr[start];</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		int mid = (start + end) / 2;</span><br><span class="line">		int left_node = 2 * node + 1;</span><br><span class="line">		int right_node = 2 * node + 2;</span><br><span class="line">		build_tree(left_node, start, mid);</span><br><span class="line">		build_tree(right_node, mid + 1, end);</span><br><span class="line">		tree[node] = tree[left_node] + tree[right_node];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void update_tree(int node, int start, int end, int idx, int val)</span><br><span class="line">&#123;</span><br><span class="line">	if (start == end)</span><br><span class="line">	&#123;</span><br><span class="line">		arr[idx] = val;</span><br><span class="line">		tree[node] = val;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		int mid = start + end &gt;&gt; 1;</span><br><span class="line">		int left_node = 2 * node + 1;</span><br><span class="line">		int right_node = 2 * node + 2;</span><br><span class="line">		if (idx &gt;= start &amp;&amp; idx &lt;= mid)</span><br><span class="line">		&#123;</span><br><span class="line">			update_tree(left_node, start, mid, idx, val);</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			update_tree(right_node, mid + 1, end, idx, val);</span><br><span class="line">		&#125;</span><br><span class="line">		tree[node] = tree[left_node] + tree[right_node];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int query_tree(int node, int start, int end, int L, int R)</span><br><span class="line">&#123;</span><br><span class="line">	if (R &lt; start || L &gt; end)</span><br><span class="line">	&#123;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	else if (L &lt;= start &amp;&amp; end &lt;= R)</span><br><span class="line">	&#123;</span><br><span class="line">		return tree[node];</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		int mid = (start + end) &gt;&gt; 1;</span><br><span class="line">		int left_node = 2 * node + 1;</span><br><span class="line">		int right_node = 2 * node + 2;</span><br><span class="line">		int sum_left = query_tree(left_node, start, mid, L, R);</span><br><span class="line">		int sum_right = query_tree(right_node, mid + 1, end, L, R);</span><br><span class="line">		return sum_left + sum_right;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	build_tree(0, 0, Size - 1);</span><br><span class="line">	int i;</span><br><span class="line">	for (i = 0; i &lt; 15; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;tree[%d] = %d\n&quot;, i, tree[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	update_tree(0, 0, Size - 1, 4, 6);</span><br><span class="line"></span><br><span class="line">	for (int i = 0; i &lt; 15; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;tree[%d] = %d\n&quot;, i, tree[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	int s = query_tree(0, 0, Size - 1, 2, 5);</span><br><span class="line">	cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第二版"><a href="#第二版" class="headerlink" title="第二版"></a>第二版</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="换根dp"><a href="#换根dp" class="headerlink" title="换根dp"></a>换根dp</h1><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3478">https://www.luogu.com.cn/problem/P3478</a></p>
<p>求n个结点的树，使得以某一结点为根，所有结点的深度之和最大。</p>
<p>首先算出以1为根的深度之和f[1]。</p>
<p>原来u为v的父节点，现将v作为u的父结点:</p>
<blockquote>
<p>原来以v为父结点的结点深度减一，则深度减少sz[v]。</p>
<p>原来不以v为父结点的结点深度加一，则深度加n - sz[v]。  </p>
</blockquote>
<p>则f[v] &#x3D; f[u] + n - 2 * sz[v]。</p>
<p>故需先预处理求出以v为根节点的树的结点个数sz[v]，和每个结点的深度。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; PLL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N];</span><br><span class="line"><span class="type">int</span> dep[N];</span><br><span class="line"><span class="type">int</span> sz[N];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> f[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">	sz[u] = <span class="number">1</span>;</span><br><span class="line">	dep[u] = dep[fa] + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> t : e[u]) &#123;</span><br><span class="line">		<span class="keyword">if</span>(t != fa) &#123;</span><br><span class="line">			<span class="built_in">dfs</span>(t, u);</span><br><span class="line">			sz[u] += sz[t];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_ans</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> t : e[u]) &#123;</span><br><span class="line">		<span class="keyword">if</span>(t != fa) &#123;</span><br><span class="line">			f[t] = f[u] + n - <span class="number">2</span> * sz[t];</span><br><span class="line">			<span class="built_in">get_ans</span>(t, u);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">		<span class="type">int</span> u, v;</span><br><span class="line">		cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">		e[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">		e[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) f[<span class="number">1</span>] += dep[i];</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">get_ans</span>(<span class="number">1</span> ,<span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	ll ans = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> pos = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (f[i] &gt; ans) &#123;</span><br><span class="line">			ans = f[i];</span><br><span class="line">			pos = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; pos &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="容斥-换根dp"><a href="#容斥-换根dp" class="headerlink" title="容斥+换根dp"></a>容斥+换根dp</h1><h2 id="1-题意"><a href="#1-题意" class="headerlink" title="1.题意"></a>1.题意</h2><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3047">https://www.luogu.com.cn/problem/P3047</a></p>
<p>给n个结点的树，点带权，求每个结点距其不超过k的所有结点的权值和。</p>
<h2 id="2-分析"><a href="#2-分析" class="headerlink" title="2.分析"></a>2.分析</h2><p>先找一个点作为根节点，f[u] [i]表示距离u结点i长度的权值和。</p>
<p>预处理：u为根节点，v为子节点，f[u] [i] &#x3D; f[v] [i - 1]</p>
<p>换根：设fa为父亲结点，u为当前结点，f[u] [j] 可以从 f[fa] [j - 1]转换而来，但是f[fa] [j - 1]中包含了f[u] [j - 2]，这一部分值应该剔除。所以f[u] [j] +&#x3D; f[fa] [j - 1] - f[u] [j - 2]</p>
<h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; PLL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N];</span><br><span class="line">ll f[N][<span class="number">30</span>];</span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) &#123;</span><br><span class="line">		<span class="keyword">if</span>(v == fa) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(v, u);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++) f[u][i] += f[v][i - <span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_ans</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> v : e[u]) &#123;</span><br><span class="line">		<span class="keyword">if</span>(v == fa) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = k; i &gt;= <span class="number">2</span>; i--) f[v][i] += f[u][i - <span class="number">1</span>] - f[v][i - <span class="number">2</span>];</span><br><span class="line">		f[v][<span class="number">1</span>] += f[u][<span class="number">0</span>];</span><br><span class="line">		<span class="built_in">get_ans</span>(v, u);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">		<span class="type">int</span> u, v;</span><br><span class="line">		cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">		e[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">		e[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		cin &gt;&gt; f[i][<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">get_ans</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		ll res = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= k; j++) &#123;</span><br><span class="line">			res += f[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





 
      <!-- reward -->
      
      <div id="reword-out">
        <div id="reward-btn">
          Donate
        </div>
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>Copyright： </strong>
          
          Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://example.com/2024/03/25/%E7%AE%97%E6%B3%95/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
    </footer>
  </div>

   
  <nav class="article-nav">
    
    
      <a href="/2024/03/25/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">如何搭建博客</div>
      </a>
    
  </nav>

  
   
  
   
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2024
        <i class="ri-heart-fill heart_icon"></i> Qian Xiaoo
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="岍翛"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="http://shenyu-vip.lofter.com">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>